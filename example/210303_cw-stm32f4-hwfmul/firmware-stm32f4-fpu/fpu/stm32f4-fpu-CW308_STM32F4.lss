
stm32f4-fpu-CW308_STM32F4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000016ac  08000188  08000188  00010188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000018  08001834  08001834  00011834  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800184c  0800184c  00020430  2**0
                  CONTENTS
  4 .ARM          00000000  0800184c  0800184c  00020430  2**0
                  CONTENTS
  5 .preinit_array 00000000  0800184c  0800184c  00020430  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  0800184c  0800184c  0001184c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08001854  08001854  00011854  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000430  20000000  08001858  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000134  20000430  08001c88  00020430  2**2
                  ALLOC
 10 ._user_heap_stack 00000404  20000564  08001c88  00020564  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00020430  2**0
                  CONTENTS, READONLY
 12 .comment      00000031  00000000  00000000  00020460  2**0
                  CONTENTS, READONLY
 13 .debug_info   00007c1b  00000000  00000000  00020491  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00001541  00000000  00000000  000280ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00001cc7  00000000  00000000  000295ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_aranges 000002c0  00000000  00000000  0002b2b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000330  00000000  00000000  0002b578  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   000019fd  00000000  00000000  0002b8a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    00001829  00000000  00000000  0002d2a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_frame  000006e8  00000000  00000000  0002ead0  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stab         00000144  00000000  00000000  0002f1b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .stabstr      00000034  00000000  00000000  0002f2fc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <deregister_tm_clones>:
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8000188:	4b04      	ldr	r3, [pc, #16]	; (800019c <deregister_tm_clones+0x14>)
 800018a:	4805      	ldr	r0, [pc, #20]	; (80001a0 <deregister_tm_clones+0x18>)
 800018c:	1a1b      	subs	r3, r3, r0
 800018e:	2b06      	cmp	r3, #6
 8000190:	d902      	bls.n	8000198 <deregister_tm_clones+0x10>
 8000192:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <deregister_tm_clones+0x1c>)
 8000194:	b103      	cbz	r3, 8000198 <deregister_tm_clones+0x10>
 8000196:	4718      	bx	r3
 8000198:	4770      	bx	lr
 800019a:	bf00      	nop
 800019c:	20000433 	.word	0x20000433
 80001a0:	20000430 	.word	0x20000430
 80001a4:	00000000 	.word	0x00000000

080001a8 <register_tm_clones>:
 80001a8:	4905      	ldr	r1, [pc, #20]	; (80001c0 <register_tm_clones+0x18>)
 80001aa:	4806      	ldr	r0, [pc, #24]	; (80001c4 <register_tm_clones+0x1c>)
 80001ac:	1a09      	subs	r1, r1, r0
 80001ae:	1089      	asrs	r1, r1, #2
 80001b0:	eb01 71d1 	add.w	r1, r1, r1, lsr #31
 80001b4:	1049      	asrs	r1, r1, #1
 80001b6:	d002      	beq.n	80001be <register_tm_clones+0x16>
 80001b8:	4b03      	ldr	r3, [pc, #12]	; (80001c8 <register_tm_clones+0x20>)
 80001ba:	b103      	cbz	r3, 80001be <register_tm_clones+0x16>
 80001bc:	4718      	bx	r3
 80001be:	4770      	bx	lr
 80001c0:	20000430 	.word	0x20000430
 80001c4:	20000430 	.word	0x20000430
 80001c8:	00000000 	.word	0x00000000

080001cc <__do_global_dtors_aux>:
 80001cc:	b510      	push	{r4, lr}
 80001ce:	4c06      	ldr	r4, [pc, #24]	; (80001e8 <__do_global_dtors_aux+0x1c>)
 80001d0:	7823      	ldrb	r3, [r4, #0]
 80001d2:	b943      	cbnz	r3, 80001e6 <__do_global_dtors_aux+0x1a>
 80001d4:	f7ff ffd8 	bl	8000188 <deregister_tm_clones>
 80001d8:	4b04      	ldr	r3, [pc, #16]	; (80001ec <__do_global_dtors_aux+0x20>)
 80001da:	b113      	cbz	r3, 80001e2 <__do_global_dtors_aux+0x16>
 80001dc:	4804      	ldr	r0, [pc, #16]	; (80001f0 <__do_global_dtors_aux+0x24>)
 80001de:	f3af 8000 	nop.w
 80001e2:	2301      	movs	r3, #1
 80001e4:	7023      	strb	r3, [r4, #0]
 80001e6:	bd10      	pop	{r4, pc}
 80001e8:	20000430 	.word	0x20000430
 80001ec:	00000000 	.word	0x00000000
 80001f0:	0800181c 	.word	0x0800181c

080001f4 <frame_dummy>:
 80001f4:	b508      	push	{r3, lr}
 80001f6:	4b08      	ldr	r3, [pc, #32]	; (8000218 <frame_dummy+0x24>)
 80001f8:	b11b      	cbz	r3, 8000202 <frame_dummy+0xe>
 80001fa:	4908      	ldr	r1, [pc, #32]	; (800021c <frame_dummy+0x28>)
 80001fc:	4808      	ldr	r0, [pc, #32]	; (8000220 <frame_dummy+0x2c>)
 80001fe:	f3af 8000 	nop.w
 8000202:	4808      	ldr	r0, [pc, #32]	; (8000224 <frame_dummy+0x30>)
 8000204:	6803      	ldr	r3, [r0, #0]
 8000206:	b913      	cbnz	r3, 800020e <frame_dummy+0x1a>
 8000208:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800020c:	e7cc      	b.n	80001a8 <register_tm_clones>
 800020e:	4b06      	ldr	r3, [pc, #24]	; (8000228 <frame_dummy+0x34>)
 8000210:	2b00      	cmp	r3, #0
 8000212:	d0f9      	beq.n	8000208 <frame_dummy+0x14>
 8000214:	4798      	blx	r3
 8000216:	e7f7      	b.n	8000208 <frame_dummy+0x14>
 8000218:	00000000 	.word	0x00000000
 800021c:	20000434 	.word	0x20000434
 8000220:	0800181c 	.word	0x0800181c
 8000224:	20000430 	.word	0x20000430
 8000228:	00000000 	.word	0x00000000

0800022c <__aeabi_drsub>:
 800022c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000230:	e002      	b.n	8000238 <__adddf3>
 8000232:	bf00      	nop

08000234 <__aeabi_dsub>:
 8000234:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000238 <__adddf3>:
 8000238:	b530      	push	{r4, r5, lr}
 800023a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800023e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000242:	ea94 0f05 	teq	r4, r5
 8000246:	bf08      	it	eq
 8000248:	ea90 0f02 	teqeq	r0, r2
 800024c:	bf1f      	itttt	ne
 800024e:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000252:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000256:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800025a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800025e:	f000 80e2 	beq.w	8000426 <__adddf3+0x1ee>
 8000262:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000266:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800026a:	bfb8      	it	lt
 800026c:	426d      	neglt	r5, r5
 800026e:	dd0c      	ble.n	800028a <__adddf3+0x52>
 8000270:	442c      	add	r4, r5
 8000272:	ea80 0202 	eor.w	r2, r0, r2
 8000276:	ea81 0303 	eor.w	r3, r1, r3
 800027a:	ea82 0000 	eor.w	r0, r2, r0
 800027e:	ea83 0101 	eor.w	r1, r3, r1
 8000282:	ea80 0202 	eor.w	r2, r0, r2
 8000286:	ea81 0303 	eor.w	r3, r1, r3
 800028a:	2d36      	cmp	r5, #54	; 0x36
 800028c:	bf88      	it	hi
 800028e:	bd30      	pophi	{r4, r5, pc}
 8000290:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000294:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000298:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800029c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80002a0:	d002      	beq.n	80002a8 <__adddf3+0x70>
 80002a2:	4240      	negs	r0, r0
 80002a4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80002a8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80002ac:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80002b0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80002b4:	d002      	beq.n	80002bc <__adddf3+0x84>
 80002b6:	4252      	negs	r2, r2
 80002b8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80002bc:	ea94 0f05 	teq	r4, r5
 80002c0:	f000 80a7 	beq.w	8000412 <__adddf3+0x1da>
 80002c4:	f1a4 0401 	sub.w	r4, r4, #1
 80002c8:	f1d5 0e20 	rsbs	lr, r5, #32
 80002cc:	db0d      	blt.n	80002ea <__adddf3+0xb2>
 80002ce:	fa02 fc0e 	lsl.w	ip, r2, lr
 80002d2:	fa22 f205 	lsr.w	r2, r2, r5
 80002d6:	1880      	adds	r0, r0, r2
 80002d8:	f141 0100 	adc.w	r1, r1, #0
 80002dc:	fa03 f20e 	lsl.w	r2, r3, lr
 80002e0:	1880      	adds	r0, r0, r2
 80002e2:	fa43 f305 	asr.w	r3, r3, r5
 80002e6:	4159      	adcs	r1, r3
 80002e8:	e00e      	b.n	8000308 <__adddf3+0xd0>
 80002ea:	f1a5 0520 	sub.w	r5, r5, #32
 80002ee:	f10e 0e20 	add.w	lr, lr, #32
 80002f2:	2a01      	cmp	r2, #1
 80002f4:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002f8:	bf28      	it	cs
 80002fa:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002fe:	fa43 f305 	asr.w	r3, r3, r5
 8000302:	18c0      	adds	r0, r0, r3
 8000304:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8000308:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800030c:	d507      	bpl.n	800031e <__adddf3+0xe6>
 800030e:	f04f 0e00 	mov.w	lr, #0
 8000312:	f1dc 0c00 	rsbs	ip, ip, #0
 8000316:	eb7e 0000 	sbcs.w	r0, lr, r0
 800031a:	eb6e 0101 	sbc.w	r1, lr, r1
 800031e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000322:	d31b      	bcc.n	800035c <__adddf3+0x124>
 8000324:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000328:	d30c      	bcc.n	8000344 <__adddf3+0x10c>
 800032a:	0849      	lsrs	r1, r1, #1
 800032c:	ea5f 0030 	movs.w	r0, r0, rrx
 8000330:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000334:	f104 0401 	add.w	r4, r4, #1
 8000338:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800033c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000340:	f080 809a 	bcs.w	8000478 <__adddf3+0x240>
 8000344:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000348:	bf08      	it	eq
 800034a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800034e:	f150 0000 	adcs.w	r0, r0, #0
 8000352:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000356:	ea41 0105 	orr.w	r1, r1, r5
 800035a:	bd30      	pop	{r4, r5, pc}
 800035c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000360:	4140      	adcs	r0, r0
 8000362:	eb41 0101 	adc.w	r1, r1, r1
 8000366:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800036a:	f1a4 0401 	sub.w	r4, r4, #1
 800036e:	d1e9      	bne.n	8000344 <__adddf3+0x10c>
 8000370:	f091 0f00 	teq	r1, #0
 8000374:	bf04      	itt	eq
 8000376:	4601      	moveq	r1, r0
 8000378:	2000      	moveq	r0, #0
 800037a:	fab1 f381 	clz	r3, r1
 800037e:	bf08      	it	eq
 8000380:	3320      	addeq	r3, #32
 8000382:	f1a3 030b 	sub.w	r3, r3, #11
 8000386:	f1b3 0220 	subs.w	r2, r3, #32
 800038a:	da0c      	bge.n	80003a6 <__adddf3+0x16e>
 800038c:	320c      	adds	r2, #12
 800038e:	dd08      	ble.n	80003a2 <__adddf3+0x16a>
 8000390:	f102 0c14 	add.w	ip, r2, #20
 8000394:	f1c2 020c 	rsb	r2, r2, #12
 8000398:	fa01 f00c 	lsl.w	r0, r1, ip
 800039c:	fa21 f102 	lsr.w	r1, r1, r2
 80003a0:	e00c      	b.n	80003bc <__adddf3+0x184>
 80003a2:	f102 0214 	add.w	r2, r2, #20
 80003a6:	bfd8      	it	le
 80003a8:	f1c2 0c20 	rsble	ip, r2, #32
 80003ac:	fa01 f102 	lsl.w	r1, r1, r2
 80003b0:	fa20 fc0c 	lsr.w	ip, r0, ip
 80003b4:	bfdc      	itt	le
 80003b6:	ea41 010c 	orrle.w	r1, r1, ip
 80003ba:	4090      	lslle	r0, r2
 80003bc:	1ae4      	subs	r4, r4, r3
 80003be:	bfa2      	ittt	ge
 80003c0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80003c4:	4329      	orrge	r1, r5
 80003c6:	bd30      	popge	{r4, r5, pc}
 80003c8:	ea6f 0404 	mvn.w	r4, r4
 80003cc:	3c1f      	subs	r4, #31
 80003ce:	da1c      	bge.n	800040a <__adddf3+0x1d2>
 80003d0:	340c      	adds	r4, #12
 80003d2:	dc0e      	bgt.n	80003f2 <__adddf3+0x1ba>
 80003d4:	f104 0414 	add.w	r4, r4, #20
 80003d8:	f1c4 0220 	rsb	r2, r4, #32
 80003dc:	fa20 f004 	lsr.w	r0, r0, r4
 80003e0:	fa01 f302 	lsl.w	r3, r1, r2
 80003e4:	ea40 0003 	orr.w	r0, r0, r3
 80003e8:	fa21 f304 	lsr.w	r3, r1, r4
 80003ec:	ea45 0103 	orr.w	r1, r5, r3
 80003f0:	bd30      	pop	{r4, r5, pc}
 80003f2:	f1c4 040c 	rsb	r4, r4, #12
 80003f6:	f1c4 0220 	rsb	r2, r4, #32
 80003fa:	fa20 f002 	lsr.w	r0, r0, r2
 80003fe:	fa01 f304 	lsl.w	r3, r1, r4
 8000402:	ea40 0003 	orr.w	r0, r0, r3
 8000406:	4629      	mov	r1, r5
 8000408:	bd30      	pop	{r4, r5, pc}
 800040a:	fa21 f004 	lsr.w	r0, r1, r4
 800040e:	4629      	mov	r1, r5
 8000410:	bd30      	pop	{r4, r5, pc}
 8000412:	f094 0f00 	teq	r4, #0
 8000416:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800041a:	bf06      	itte	eq
 800041c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000420:	3401      	addeq	r4, #1
 8000422:	3d01      	subne	r5, #1
 8000424:	e74e      	b.n	80002c4 <__adddf3+0x8c>
 8000426:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800042a:	bf18      	it	ne
 800042c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000430:	d029      	beq.n	8000486 <__adddf3+0x24e>
 8000432:	ea94 0f05 	teq	r4, r5
 8000436:	bf08      	it	eq
 8000438:	ea90 0f02 	teqeq	r0, r2
 800043c:	d005      	beq.n	800044a <__adddf3+0x212>
 800043e:	ea54 0c00 	orrs.w	ip, r4, r0
 8000442:	bf04      	itt	eq
 8000444:	4619      	moveq	r1, r3
 8000446:	4610      	moveq	r0, r2
 8000448:	bd30      	pop	{r4, r5, pc}
 800044a:	ea91 0f03 	teq	r1, r3
 800044e:	bf1e      	ittt	ne
 8000450:	2100      	movne	r1, #0
 8000452:	2000      	movne	r0, #0
 8000454:	bd30      	popne	{r4, r5, pc}
 8000456:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800045a:	d105      	bne.n	8000468 <__adddf3+0x230>
 800045c:	0040      	lsls	r0, r0, #1
 800045e:	4149      	adcs	r1, r1
 8000460:	bf28      	it	cs
 8000462:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000466:	bd30      	pop	{r4, r5, pc}
 8000468:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800046c:	bf3c      	itt	cc
 800046e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000472:	bd30      	popcc	{r4, r5, pc}
 8000474:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000478:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800047c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000480:	f04f 0000 	mov.w	r0, #0
 8000484:	bd30      	pop	{r4, r5, pc}
 8000486:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800048a:	bf1a      	itte	ne
 800048c:	4619      	movne	r1, r3
 800048e:	4610      	movne	r0, r2
 8000490:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000494:	bf1c      	itt	ne
 8000496:	460b      	movne	r3, r1
 8000498:	4602      	movne	r2, r0
 800049a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800049e:	bf06      	itte	eq
 80004a0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80004a4:	ea91 0f03 	teqeq	r1, r3
 80004a8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	bf00      	nop

080004b0 <__aeabi_ui2d>:
 80004b0:	f090 0f00 	teq	r0, #0
 80004b4:	bf04      	itt	eq
 80004b6:	2100      	moveq	r1, #0
 80004b8:	4770      	bxeq	lr
 80004ba:	b530      	push	{r4, r5, lr}
 80004bc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004c0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004c4:	f04f 0500 	mov.w	r5, #0
 80004c8:	f04f 0100 	mov.w	r1, #0
 80004cc:	e750      	b.n	8000370 <__adddf3+0x138>
 80004ce:	bf00      	nop

080004d0 <__aeabi_i2d>:
 80004d0:	f090 0f00 	teq	r0, #0
 80004d4:	bf04      	itt	eq
 80004d6:	2100      	moveq	r1, #0
 80004d8:	4770      	bxeq	lr
 80004da:	b530      	push	{r4, r5, lr}
 80004dc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80004e0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80004e4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80004e8:	bf48      	it	mi
 80004ea:	4240      	negmi	r0, r0
 80004ec:	f04f 0100 	mov.w	r1, #0
 80004f0:	e73e      	b.n	8000370 <__adddf3+0x138>
 80004f2:	bf00      	nop

080004f4 <__aeabi_f2d>:
 80004f4:	0042      	lsls	r2, r0, #1
 80004f6:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004fa:	ea4f 0131 	mov.w	r1, r1, rrx
 80004fe:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000502:	bf1f      	itttt	ne
 8000504:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8000508:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800050c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000510:	4770      	bxne	lr
 8000512:	f092 0f00 	teq	r2, #0
 8000516:	bf14      	ite	ne
 8000518:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800051c:	4770      	bxeq	lr
 800051e:	b530      	push	{r4, r5, lr}
 8000520:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000524:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000528:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800052c:	e720      	b.n	8000370 <__adddf3+0x138>
 800052e:	bf00      	nop

08000530 <__aeabi_ul2d>:
 8000530:	ea50 0201 	orrs.w	r2, r0, r1
 8000534:	bf08      	it	eq
 8000536:	4770      	bxeq	lr
 8000538:	b530      	push	{r4, r5, lr}
 800053a:	f04f 0500 	mov.w	r5, #0
 800053e:	e00a      	b.n	8000556 <__aeabi_l2d+0x16>

08000540 <__aeabi_l2d>:
 8000540:	ea50 0201 	orrs.w	r2, r0, r1
 8000544:	bf08      	it	eq
 8000546:	4770      	bxeq	lr
 8000548:	b530      	push	{r4, r5, lr}
 800054a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800054e:	d502      	bpl.n	8000556 <__aeabi_l2d+0x16>
 8000550:	4240      	negs	r0, r0
 8000552:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000556:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800055a:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800055e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000562:	f43f aedc 	beq.w	800031e <__adddf3+0xe6>
 8000566:	f04f 0203 	mov.w	r2, #3
 800056a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800056e:	bf18      	it	ne
 8000570:	3203      	addne	r2, #3
 8000572:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000576:	bf18      	it	ne
 8000578:	3203      	addne	r2, #3
 800057a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800057e:	f1c2 0320 	rsb	r3, r2, #32
 8000582:	fa00 fc03 	lsl.w	ip, r0, r3
 8000586:	fa20 f002 	lsr.w	r0, r0, r2
 800058a:	fa01 fe03 	lsl.w	lr, r1, r3
 800058e:	ea40 000e 	orr.w	r0, r0, lr
 8000592:	fa21 f102 	lsr.w	r1, r1, r2
 8000596:	4414      	add	r4, r2
 8000598:	e6c1      	b.n	800031e <__adddf3+0xe6>
 800059a:	bf00      	nop

0800059c <__aeabi_dmul>:
 800059c:	b570      	push	{r4, r5, r6, lr}
 800059e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80005a2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80005a6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80005aa:	bf1d      	ittte	ne
 80005ac:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80005b0:	ea94 0f0c 	teqne	r4, ip
 80005b4:	ea95 0f0c 	teqne	r5, ip
 80005b8:	f000 f8de 	bleq	8000778 <__aeabi_dmul+0x1dc>
 80005bc:	442c      	add	r4, r5
 80005be:	ea81 0603 	eor.w	r6, r1, r3
 80005c2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80005c6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80005ca:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80005ce:	bf18      	it	ne
 80005d0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80005d4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80005d8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80005dc:	d038      	beq.n	8000650 <__aeabi_dmul+0xb4>
 80005de:	fba0 ce02 	umull	ip, lr, r0, r2
 80005e2:	f04f 0500 	mov.w	r5, #0
 80005e6:	fbe1 e502 	umlal	lr, r5, r1, r2
 80005ea:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80005ee:	fbe0 e503 	umlal	lr, r5, r0, r3
 80005f2:	f04f 0600 	mov.w	r6, #0
 80005f6:	fbe1 5603 	umlal	r5, r6, r1, r3
 80005fa:	f09c 0f00 	teq	ip, #0
 80005fe:	bf18      	it	ne
 8000600:	f04e 0e01 	orrne.w	lr, lr, #1
 8000604:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000608:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800060c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000610:	d204      	bcs.n	800061c <__aeabi_dmul+0x80>
 8000612:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000616:	416d      	adcs	r5, r5
 8000618:	eb46 0606 	adc.w	r6, r6, r6
 800061c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000620:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000624:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000628:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800062c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000630:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000634:	bf88      	it	hi
 8000636:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800063a:	d81e      	bhi.n	800067a <__aeabi_dmul+0xde>
 800063c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000640:	bf08      	it	eq
 8000642:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000646:	f150 0000 	adcs.w	r0, r0, #0
 800064a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800064e:	bd70      	pop	{r4, r5, r6, pc}
 8000650:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000654:	ea46 0101 	orr.w	r1, r6, r1
 8000658:	ea40 0002 	orr.w	r0, r0, r2
 800065c:	ea81 0103 	eor.w	r1, r1, r3
 8000660:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000664:	bfc2      	ittt	gt
 8000666:	ebd4 050c 	rsbsgt	r5, r4, ip
 800066a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800066e:	bd70      	popgt	{r4, r5, r6, pc}
 8000670:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000674:	f04f 0e00 	mov.w	lr, #0
 8000678:	3c01      	subs	r4, #1
 800067a:	f300 80ab 	bgt.w	80007d4 <__aeabi_dmul+0x238>
 800067e:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000682:	bfde      	ittt	le
 8000684:	2000      	movle	r0, #0
 8000686:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800068a:	bd70      	pople	{r4, r5, r6, pc}
 800068c:	f1c4 0400 	rsb	r4, r4, #0
 8000690:	3c20      	subs	r4, #32
 8000692:	da35      	bge.n	8000700 <__aeabi_dmul+0x164>
 8000694:	340c      	adds	r4, #12
 8000696:	dc1b      	bgt.n	80006d0 <__aeabi_dmul+0x134>
 8000698:	f104 0414 	add.w	r4, r4, #20
 800069c:	f1c4 0520 	rsb	r5, r4, #32
 80006a0:	fa00 f305 	lsl.w	r3, r0, r5
 80006a4:	fa20 f004 	lsr.w	r0, r0, r4
 80006a8:	fa01 f205 	lsl.w	r2, r1, r5
 80006ac:	ea40 0002 	orr.w	r0, r0, r2
 80006b0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80006b4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80006b8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006bc:	fa21 f604 	lsr.w	r6, r1, r4
 80006c0:	eb42 0106 	adc.w	r1, r2, r6
 80006c4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006c8:	bf08      	it	eq
 80006ca:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006ce:	bd70      	pop	{r4, r5, r6, pc}
 80006d0:	f1c4 040c 	rsb	r4, r4, #12
 80006d4:	f1c4 0520 	rsb	r5, r4, #32
 80006d8:	fa00 f304 	lsl.w	r3, r0, r4
 80006dc:	fa20 f005 	lsr.w	r0, r0, r5
 80006e0:	fa01 f204 	lsl.w	r2, r1, r4
 80006e4:	ea40 0002 	orr.w	r0, r0, r2
 80006e8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006ec:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80006f0:	f141 0100 	adc.w	r1, r1, #0
 80006f4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80006f8:	bf08      	it	eq
 80006fa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80006fe:	bd70      	pop	{r4, r5, r6, pc}
 8000700:	f1c4 0520 	rsb	r5, r4, #32
 8000704:	fa00 f205 	lsl.w	r2, r0, r5
 8000708:	ea4e 0e02 	orr.w	lr, lr, r2
 800070c:	fa20 f304 	lsr.w	r3, r0, r4
 8000710:	fa01 f205 	lsl.w	r2, r1, r5
 8000714:	ea43 0302 	orr.w	r3, r3, r2
 8000718:	fa21 f004 	lsr.w	r0, r1, r4
 800071c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000720:	fa21 f204 	lsr.w	r2, r1, r4
 8000724:	ea20 0002 	bic.w	r0, r0, r2
 8000728:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800072c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000730:	bf08      	it	eq
 8000732:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000736:	bd70      	pop	{r4, r5, r6, pc}
 8000738:	f094 0f00 	teq	r4, #0
 800073c:	d10f      	bne.n	800075e <__aeabi_dmul+0x1c2>
 800073e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000742:	0040      	lsls	r0, r0, #1
 8000744:	eb41 0101 	adc.w	r1, r1, r1
 8000748:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800074c:	bf08      	it	eq
 800074e:	3c01      	subeq	r4, #1
 8000750:	d0f7      	beq.n	8000742 <__aeabi_dmul+0x1a6>
 8000752:	ea41 0106 	orr.w	r1, r1, r6
 8000756:	f095 0f00 	teq	r5, #0
 800075a:	bf18      	it	ne
 800075c:	4770      	bxne	lr
 800075e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000762:	0052      	lsls	r2, r2, #1
 8000764:	eb43 0303 	adc.w	r3, r3, r3
 8000768:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800076c:	bf08      	it	eq
 800076e:	3d01      	subeq	r5, #1
 8000770:	d0f7      	beq.n	8000762 <__aeabi_dmul+0x1c6>
 8000772:	ea43 0306 	orr.w	r3, r3, r6
 8000776:	4770      	bx	lr
 8000778:	ea94 0f0c 	teq	r4, ip
 800077c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000780:	bf18      	it	ne
 8000782:	ea95 0f0c 	teqne	r5, ip
 8000786:	d00c      	beq.n	80007a2 <__aeabi_dmul+0x206>
 8000788:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800078c:	bf18      	it	ne
 800078e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000792:	d1d1      	bne.n	8000738 <__aeabi_dmul+0x19c>
 8000794:	ea81 0103 	eor.w	r1, r1, r3
 8000798:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800079c:	f04f 0000 	mov.w	r0, #0
 80007a0:	bd70      	pop	{r4, r5, r6, pc}
 80007a2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80007a6:	bf06      	itte	eq
 80007a8:	4610      	moveq	r0, r2
 80007aa:	4619      	moveq	r1, r3
 80007ac:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80007b0:	d019      	beq.n	80007e6 <__aeabi_dmul+0x24a>
 80007b2:	ea94 0f0c 	teq	r4, ip
 80007b6:	d102      	bne.n	80007be <__aeabi_dmul+0x222>
 80007b8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80007bc:	d113      	bne.n	80007e6 <__aeabi_dmul+0x24a>
 80007be:	ea95 0f0c 	teq	r5, ip
 80007c2:	d105      	bne.n	80007d0 <__aeabi_dmul+0x234>
 80007c4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80007c8:	bf1c      	itt	ne
 80007ca:	4610      	movne	r0, r2
 80007cc:	4619      	movne	r1, r3
 80007ce:	d10a      	bne.n	80007e6 <__aeabi_dmul+0x24a>
 80007d0:	ea81 0103 	eor.w	r1, r1, r3
 80007d4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007d8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80007dc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80007e0:	f04f 0000 	mov.w	r0, #0
 80007e4:	bd70      	pop	{r4, r5, r6, pc}
 80007e6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80007ea:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80007ee:	bd70      	pop	{r4, r5, r6, pc}

080007f0 <__aeabi_ddiv>:
 80007f0:	b570      	push	{r4, r5, r6, lr}
 80007f2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80007f6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80007fa:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80007fe:	bf1d      	ittte	ne
 8000800:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000804:	ea94 0f0c 	teqne	r4, ip
 8000808:	ea95 0f0c 	teqne	r5, ip
 800080c:	f000 f8a7 	bleq	800095e <__aeabi_ddiv+0x16e>
 8000810:	eba4 0405 	sub.w	r4, r4, r5
 8000814:	ea81 0e03 	eor.w	lr, r1, r3
 8000818:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800081c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000820:	f000 8088 	beq.w	8000934 <__aeabi_ddiv+0x144>
 8000824:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000828:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800082c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000830:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000834:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000838:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800083c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000840:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000844:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000848:	429d      	cmp	r5, r3
 800084a:	bf08      	it	eq
 800084c:	4296      	cmpeq	r6, r2
 800084e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000852:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000856:	d202      	bcs.n	800085e <__aeabi_ddiv+0x6e>
 8000858:	085b      	lsrs	r3, r3, #1
 800085a:	ea4f 0232 	mov.w	r2, r2, rrx
 800085e:	1ab6      	subs	r6, r6, r2
 8000860:	eb65 0503 	sbc.w	r5, r5, r3
 8000864:	085b      	lsrs	r3, r3, #1
 8000866:	ea4f 0232 	mov.w	r2, r2, rrx
 800086a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800086e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000872:	ebb6 0e02 	subs.w	lr, r6, r2
 8000876:	eb75 0e03 	sbcs.w	lr, r5, r3
 800087a:	bf22      	ittt	cs
 800087c:	1ab6      	subcs	r6, r6, r2
 800087e:	4675      	movcs	r5, lr
 8000880:	ea40 000c 	orrcs.w	r0, r0, ip
 8000884:	085b      	lsrs	r3, r3, #1
 8000886:	ea4f 0232 	mov.w	r2, r2, rrx
 800088a:	ebb6 0e02 	subs.w	lr, r6, r2
 800088e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000892:	bf22      	ittt	cs
 8000894:	1ab6      	subcs	r6, r6, r2
 8000896:	4675      	movcs	r5, lr
 8000898:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800089c:	085b      	lsrs	r3, r3, #1
 800089e:	ea4f 0232 	mov.w	r2, r2, rrx
 80008a2:	ebb6 0e02 	subs.w	lr, r6, r2
 80008a6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008aa:	bf22      	ittt	cs
 80008ac:	1ab6      	subcs	r6, r6, r2
 80008ae:	4675      	movcs	r5, lr
 80008b0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80008b4:	085b      	lsrs	r3, r3, #1
 80008b6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ba:	ebb6 0e02 	subs.w	lr, r6, r2
 80008be:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008c2:	bf22      	ittt	cs
 80008c4:	1ab6      	subcs	r6, r6, r2
 80008c6:	4675      	movcs	r5, lr
 80008c8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80008cc:	ea55 0e06 	orrs.w	lr, r5, r6
 80008d0:	d018      	beq.n	8000904 <__aeabi_ddiv+0x114>
 80008d2:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80008d6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80008da:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80008de:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80008e2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80008e6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80008ea:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80008ee:	d1c0      	bne.n	8000872 <__aeabi_ddiv+0x82>
 80008f0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80008f4:	d10b      	bne.n	800090e <__aeabi_ddiv+0x11e>
 80008f6:	ea41 0100 	orr.w	r1, r1, r0
 80008fa:	f04f 0000 	mov.w	r0, #0
 80008fe:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000902:	e7b6      	b.n	8000872 <__aeabi_ddiv+0x82>
 8000904:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000908:	bf04      	itt	eq
 800090a:	4301      	orreq	r1, r0
 800090c:	2000      	moveq	r0, #0
 800090e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000912:	bf88      	it	hi
 8000914:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000918:	f63f aeaf 	bhi.w	800067a <__aeabi_dmul+0xde>
 800091c:	ebb5 0c03 	subs.w	ip, r5, r3
 8000920:	bf04      	itt	eq
 8000922:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000926:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800092a:	f150 0000 	adcs.w	r0, r0, #0
 800092e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000932:	bd70      	pop	{r4, r5, r6, pc}
 8000934:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000938:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800093c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000940:	bfc2      	ittt	gt
 8000942:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000946:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800094a:	bd70      	popgt	{r4, r5, r6, pc}
 800094c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000950:	f04f 0e00 	mov.w	lr, #0
 8000954:	3c01      	subs	r4, #1
 8000956:	e690      	b.n	800067a <__aeabi_dmul+0xde>
 8000958:	ea45 0e06 	orr.w	lr, r5, r6
 800095c:	e68d      	b.n	800067a <__aeabi_dmul+0xde>
 800095e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000962:	ea94 0f0c 	teq	r4, ip
 8000966:	bf08      	it	eq
 8000968:	ea95 0f0c 	teqeq	r5, ip
 800096c:	f43f af3b 	beq.w	80007e6 <__aeabi_dmul+0x24a>
 8000970:	ea94 0f0c 	teq	r4, ip
 8000974:	d10a      	bne.n	800098c <__aeabi_ddiv+0x19c>
 8000976:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800097a:	f47f af34 	bne.w	80007e6 <__aeabi_dmul+0x24a>
 800097e:	ea95 0f0c 	teq	r5, ip
 8000982:	f47f af25 	bne.w	80007d0 <__aeabi_dmul+0x234>
 8000986:	4610      	mov	r0, r2
 8000988:	4619      	mov	r1, r3
 800098a:	e72c      	b.n	80007e6 <__aeabi_dmul+0x24a>
 800098c:	ea95 0f0c 	teq	r5, ip
 8000990:	d106      	bne.n	80009a0 <__aeabi_ddiv+0x1b0>
 8000992:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000996:	f43f aefd 	beq.w	8000794 <__aeabi_dmul+0x1f8>
 800099a:	4610      	mov	r0, r2
 800099c:	4619      	mov	r1, r3
 800099e:	e722      	b.n	80007e6 <__aeabi_dmul+0x24a>
 80009a0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80009a4:	bf18      	it	ne
 80009a6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009aa:	f47f aec5 	bne.w	8000738 <__aeabi_dmul+0x19c>
 80009ae:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80009b2:	f47f af0d 	bne.w	80007d0 <__aeabi_dmul+0x234>
 80009b6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80009ba:	f47f aeeb 	bne.w	8000794 <__aeabi_dmul+0x1f8>
 80009be:	e712      	b.n	80007e6 <__aeabi_dmul+0x24a>

080009c0 <__aeabi_d2f>:
 80009c0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80009c4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80009c8:	bf24      	itt	cs
 80009ca:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80009ce:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80009d2:	d90d      	bls.n	80009f0 <__aeabi_d2f+0x30>
 80009d4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80009d8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80009dc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80009e0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80009e4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80009e8:	bf08      	it	eq
 80009ea:	f020 0001 	biceq.w	r0, r0, #1
 80009ee:	4770      	bx	lr
 80009f0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80009f4:	d121      	bne.n	8000a3a <__aeabi_d2f+0x7a>
 80009f6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80009fa:	bfbc      	itt	lt
 80009fc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000a00:	4770      	bxlt	lr
 8000a02:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a06:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000a0a:	f1c2 0218 	rsb	r2, r2, #24
 8000a0e:	f1c2 0c20 	rsb	ip, r2, #32
 8000a12:	fa10 f30c 	lsls.w	r3, r0, ip
 8000a16:	fa20 f002 	lsr.w	r0, r0, r2
 8000a1a:	bf18      	it	ne
 8000a1c:	f040 0001 	orrne.w	r0, r0, #1
 8000a20:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a24:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000a28:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000a2c:	ea40 000c 	orr.w	r0, r0, ip
 8000a30:	fa23 f302 	lsr.w	r3, r3, r2
 8000a34:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000a38:	e7cc      	b.n	80009d4 <__aeabi_d2f+0x14>
 8000a3a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000a3e:	d107      	bne.n	8000a50 <__aeabi_d2f+0x90>
 8000a40:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000a44:	bf1e      	ittt	ne
 8000a46:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000a4a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000a4e:	4770      	bxne	lr
 8000a50:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000a54:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000a58:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000a5c:	4770      	bx	lr
 8000a5e:	bf00      	nop

08000a60 <atexit>:
 8000a60:	2300      	movs	r3, #0
 8000a62:	4601      	mov	r1, r0
 8000a64:	461a      	mov	r2, r3
 8000a66:	4618      	mov	r0, r3
 8000a68:	f000 b842 	b.w	8000af0 <__register_exitproc>

08000a6c <__libc_fini_array>:
 8000a6c:	b538      	push	{r3, r4, r5, lr}
 8000a6e:	4c0a      	ldr	r4, [pc, #40]	; (8000a98 <__libc_fini_array+0x2c>)
 8000a70:	4d0a      	ldr	r5, [pc, #40]	; (8000a9c <__libc_fini_array+0x30>)
 8000a72:	1b64      	subs	r4, r4, r5
 8000a74:	10a4      	asrs	r4, r4, #2
 8000a76:	d00a      	beq.n	8000a8e <__libc_fini_array+0x22>
 8000a78:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
 8000a7c:	3b01      	subs	r3, #1
 8000a7e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 8000a82:	3c01      	subs	r4, #1
 8000a84:	f855 3904 	ldr.w	r3, [r5], #-4
 8000a88:	4798      	blx	r3
 8000a8a:	2c00      	cmp	r4, #0
 8000a8c:	d1f9      	bne.n	8000a82 <__libc_fini_array+0x16>
 8000a8e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000a92:	f000 bec9 	b.w	8001828 <_fini>
 8000a96:	bf00      	nop
 8000a98:	08001858 	.word	0x08001858
 8000a9c:	08001854 	.word	0x08001854

08000aa0 <__libc_init_array>:
 8000aa0:	b570      	push	{r4, r5, r6, lr}
 8000aa2:	4e0f      	ldr	r6, [pc, #60]	; (8000ae0 <__libc_init_array+0x40>)
 8000aa4:	4d0f      	ldr	r5, [pc, #60]	; (8000ae4 <__libc_init_array+0x44>)
 8000aa6:	1b76      	subs	r6, r6, r5
 8000aa8:	10b6      	asrs	r6, r6, #2
 8000aaa:	bf18      	it	ne
 8000aac:	2400      	movne	r4, #0
 8000aae:	d005      	beq.n	8000abc <__libc_init_array+0x1c>
 8000ab0:	3401      	adds	r4, #1
 8000ab2:	f855 3b04 	ldr.w	r3, [r5], #4
 8000ab6:	4798      	blx	r3
 8000ab8:	42a6      	cmp	r6, r4
 8000aba:	d1f9      	bne.n	8000ab0 <__libc_init_array+0x10>
 8000abc:	4e0a      	ldr	r6, [pc, #40]	; (8000ae8 <__libc_init_array+0x48>)
 8000abe:	4d0b      	ldr	r5, [pc, #44]	; (8000aec <__libc_init_array+0x4c>)
 8000ac0:	1b76      	subs	r6, r6, r5
 8000ac2:	f000 feab 	bl	800181c <_init>
 8000ac6:	10b6      	asrs	r6, r6, #2
 8000ac8:	bf18      	it	ne
 8000aca:	2400      	movne	r4, #0
 8000acc:	d006      	beq.n	8000adc <__libc_init_array+0x3c>
 8000ace:	3401      	adds	r4, #1
 8000ad0:	f855 3b04 	ldr.w	r3, [r5], #4
 8000ad4:	4798      	blx	r3
 8000ad6:	42a6      	cmp	r6, r4
 8000ad8:	d1f9      	bne.n	8000ace <__libc_init_array+0x2e>
 8000ada:	bd70      	pop	{r4, r5, r6, pc}
 8000adc:	bd70      	pop	{r4, r5, r6, pc}
 8000ade:	bf00      	nop
 8000ae0:	0800184c 	.word	0x0800184c
 8000ae4:	0800184c 	.word	0x0800184c
 8000ae8:	08001854 	.word	0x08001854
 8000aec:	0800184c 	.word	0x0800184c

08000af0 <__register_exitproc>:
 8000af0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000af4:	4c25      	ldr	r4, [pc, #148]	; (8000b8c <__register_exitproc+0x9c>)
 8000af6:	6825      	ldr	r5, [r4, #0]
 8000af8:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
 8000afc:	4606      	mov	r6, r0
 8000afe:	4688      	mov	r8, r1
 8000b00:	4692      	mov	sl, r2
 8000b02:	4699      	mov	r9, r3
 8000b04:	b3c4      	cbz	r4, 8000b78 <__register_exitproc+0x88>
 8000b06:	6860      	ldr	r0, [r4, #4]
 8000b08:	281f      	cmp	r0, #31
 8000b0a:	dc17      	bgt.n	8000b3c <__register_exitproc+0x4c>
 8000b0c:	1c43      	adds	r3, r0, #1
 8000b0e:	b176      	cbz	r6, 8000b2e <__register_exitproc+0x3e>
 8000b10:	eb04 0580 	add.w	r5, r4, r0, lsl #2
 8000b14:	2201      	movs	r2, #1
 8000b16:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
 8000b1a:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
 8000b1e:	4082      	lsls	r2, r0
 8000b20:	4311      	orrs	r1, r2
 8000b22:	2e02      	cmp	r6, #2
 8000b24:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
 8000b28:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
 8000b2c:	d01e      	beq.n	8000b6c <__register_exitproc+0x7c>
 8000b2e:	3002      	adds	r0, #2
 8000b30:	6063      	str	r3, [r4, #4]
 8000b32:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
 8000b36:	2000      	movs	r0, #0
 8000b38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000b3c:	4b14      	ldr	r3, [pc, #80]	; (8000b90 <__register_exitproc+0xa0>)
 8000b3e:	b303      	cbz	r3, 8000b82 <__register_exitproc+0x92>
 8000b40:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8000b44:	f3af 8000 	nop.w
 8000b48:	4604      	mov	r4, r0
 8000b4a:	b1d0      	cbz	r0, 8000b82 <__register_exitproc+0x92>
 8000b4c:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
 8000b50:	2700      	movs	r7, #0
 8000b52:	e880 0088 	stmia.w	r0, {r3, r7}
 8000b56:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8000b5a:	4638      	mov	r0, r7
 8000b5c:	2301      	movs	r3, #1
 8000b5e:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
 8000b62:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
 8000b66:	2e00      	cmp	r6, #0
 8000b68:	d0e1      	beq.n	8000b2e <__register_exitproc+0x3e>
 8000b6a:	e7d1      	b.n	8000b10 <__register_exitproc+0x20>
 8000b6c:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
 8000b70:	430a      	orrs	r2, r1
 8000b72:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
 8000b76:	e7da      	b.n	8000b2e <__register_exitproc+0x3e>
 8000b78:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
 8000b7c:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
 8000b80:	e7c1      	b.n	8000b06 <__register_exitproc+0x16>
 8000b82:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000b86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000b8a:	bf00      	nop
 8000b8c:	08001844 	.word	0x08001844
 8000b90:	00000000 	.word	0x00000000

08000b94 <reset>:
}

uint8_t reset(uint8_t* x)
{
	return 0x00;
}
 8000b94:	2000      	movs	r0, #0
 8000b96:	4770      	bx	lr

08000b98 <get_pt>:
{
 8000b98:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000b9c:	b091      	sub	sp, #68	; 0x44
 8000b9e:	af04      	add	r7, sp, #16
 8000ba0:	ae08      	add	r6, sp, #32
 8000ba2:	1cc3      	adds	r3, r0, #3
        a[i] = pt[i] * 2.5 + 1;
 8000ba4:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 8000c4c <get_pt+0xb4>
 8000ba8:	9303      	str	r3, [sp, #12]
{
 8000baa:	4604      	mov	r4, r0
 8000bac:	1e45      	subs	r5, r0, #1
 8000bae:	46b9      	mov	r9, r7
 8000bb0:	46b0      	mov	r8, r6
        a[i] = pt[i] * 2.5 + 1;
 8000bb2:	f04f 0a00 	mov.w	sl, #0
 8000bb6:	f815 0f01 	ldrb.w	r0, [r5, #1]!
 8000bba:	f7ff fc89 	bl	80004d0 <__aeabi_i2d>
 8000bbe:	2200      	movs	r2, #0
 8000bc0:	4b20      	ldr	r3, [pc, #128]	; (8000c44 <get_pt+0xac>)
 8000bc2:	e9cd 0100 	strd	r0, r1, [sp]
 8000bc6:	f7ff fce9 	bl	800059c <__aeabi_dmul>
 8000bca:	4652      	mov	r2, sl
 8000bcc:	465b      	mov	r3, fp
 8000bce:	f7ff fb33 	bl	8000238 <__adddf3>
 8000bd2:	f7ff fef5 	bl	80009c0 <__aeabi_d2f>
        b[i] = pt[i] * (-2.5) - 1;
 8000bd6:	2200      	movs	r2, #0
        a[i] = pt[i] * 2.5 + 1;
 8000bd8:	f847 0b04 	str.w	r0, [r7], #4
        b[i] = pt[i] * (-2.5) - 1;
 8000bdc:	4b1a      	ldr	r3, [pc, #104]	; (8000c48 <get_pt+0xb0>)
 8000bde:	e9dd 0100 	ldrd	r0, r1, [sp]
 8000be2:	f7ff fcdb 	bl	800059c <__aeabi_dmul>
 8000be6:	465b      	mov	r3, fp
 8000be8:	4652      	mov	r2, sl
 8000bea:	f7ff fb23 	bl	8000234 <__aeabi_dsub>
 8000bee:	f7ff fee7 	bl	80009c0 <__aeabi_d2f>
    for(i = 0 ; i < 4 ;i++) {
 8000bf2:	9b03      	ldr	r3, [sp, #12]
        b[i] = pt[i] * (-2.5) - 1;
 8000bf4:	f846 0b04 	str.w	r0, [r6], #4
    for(i = 0 ; i < 4 ;i++) {
 8000bf8:	429d      	cmp	r5, r3
 8000bfa:	d1dc      	bne.n	8000bb6 <get_pt+0x1e>
    trigger_high();
 8000bfc:	f000 f976 	bl	8000eec <trigger_high>
        c[i] = a[i] * b[i];
 8000c00:	ad0c      	add	r5, sp, #48	; 0x30
    trigger_high();
 8000c02:	2300      	movs	r3, #0
        c[i] = a[i] * b[i];
 8000c04:	eb09 0003 	add.w	r0, r9, r3
 8000c08:	eb08 0103 	add.w	r1, r8, r3
 8000c0c:	edd0 7a00 	vldr	s15, [r0]
 8000c10:	ed91 7a00 	vldr	s14, [r1]
 8000c14:	18ea      	adds	r2, r5, r3
 8000c16:	ee67 7a87 	vmul.f32	s15, s15, s14
 8000c1a:	3304      	adds	r3, #4
    for(i = 0 ; i < 4 ;i++) {
 8000c1c:	2b10      	cmp	r3, #16
        c[i] = a[i] * b[i];
 8000c1e:	edc2 7a00 	vstr	s15, [r2]
    for(i = 0 ; i < 4 ;i++) {
 8000c22:	d1ef      	bne.n	8000c04 <get_pt+0x6c>
    trigger_low();
 8000c24:	f000 f96a 	bl	8000efc <trigger_low>
    for(i = 0 ; i < 16 ;i++) {
 8000c28:	2100      	movs	r1, #0
        pt[i] = pc[i];
 8000c2a:	5c6b      	ldrb	r3, [r5, r1]
 8000c2c:	5463      	strb	r3, [r4, r1]
    for(i = 0 ; i < 16 ;i++) {
 8000c2e:	3101      	adds	r1, #1
 8000c30:	2910      	cmp	r1, #16
 8000c32:	d1fa      	bne.n	8000c2a <get_pt+0x92>
	simpleserial_put('r', 16, pt);
 8000c34:	4622      	mov	r2, r4
 8000c36:	2072      	movs	r0, #114	; 0x72
 8000c38:	f000 f882 	bl	8000d40 <simpleserial_put>
}
 8000c3c:	2000      	movs	r0, #0
 8000c3e:	b011      	add	sp, #68	; 0x44
 8000c40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000c44:	40040000 	.word	0x40040000
 8000c48:	c0040000 	.word	0xc0040000
 8000c4c:	3ff00000 	.word	0x3ff00000

08000c50 <main>:

int main(void)
{
 8000c50:	b508      	push	{r3, lr}
    platform_init();
 8000c52:	f000 f8e1 	bl	8000e18 <platform_init>
	init_uart();	
 8000c56:	f000 f8f9 	bl	8000e4c <init_uart>
	trigger_setup();
 8000c5a:	f000 f933 	bl	8000ec4 <trigger_setup>
    init_fpu();
 8000c5e:	f000 f977 	bl	8000f50 <init_fpu>
	putch('l');
	putch('o');
	putch('\n');
	*/

	simpleserial_init();
 8000c62:	f000 f865 	bl	8000d30 <simpleserial_init>
    #if SS_VER == SS_VER_2_0
	;
    #else
    simpleserial_addcmd('p', 16,  get_pt);
 8000c66:	4a06      	ldr	r2, [pc, #24]	; (8000c80 <main+0x30>)
 8000c68:	2110      	movs	r1, #16
 8000c6a:	2070      	movs	r0, #112	; 0x70
 8000c6c:	f000 f84a 	bl	8000d04 <simpleserial_addcmd>
    simpleserial_addcmd('x',  0,   reset);
 8000c70:	4a04      	ldr	r2, [pc, #16]	; (8000c84 <main+0x34>)
 8000c72:	2100      	movs	r1, #0
 8000c74:	2078      	movs	r0, #120	; 0x78
 8000c76:	f000 f845 	bl	8000d04 <simpleserial_addcmd>
    #endif
    while(1)
        simpleserial_get();
 8000c7a:	f000 f883 	bl	8000d84 <simpleserial_get>
 8000c7e:	e7fc      	b.n	8000c7a <main+0x2a>
 8000c80:	08000b99 	.word	0x08000b99
 8000c84:	08000b95 	.word	0x08000b95

08000c88 <check_version>:
// Callback function for "v" command.
// This can exist in v1.0 as long as we don't actually send back an ack ("z")
uint8_t check_version(uint8_t *v)
{
	return SS_VER;
}
 8000c88:	2001      	movs	r0, #1
 8000c8a:	4770      	bx	lr

08000c8c <hex_decode>:
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};

int hex_decode(int len, char* ascii_buf, uint8_t* data_buf)
{
 8000c8c:	b570      	push	{r4, r5, r6, lr}
 8000c8e:	3101      	adds	r1, #1
	for(int i = 0; i < len; i++)
 8000c90:	4613      	mov	r3, r2
 8000c92:	1a9c      	subs	r4, r3, r2
 8000c94:	42a0      	cmp	r0, r4
 8000c96:	dc01      	bgt.n	8000c9c <hex_decode+0x10>
			data_buf[i] |= (n_hi - 'a' + 10) << 4;
		else
			return 1;
	}

	return 0;
 8000c98:	2000      	movs	r0, #0
}
 8000c9a:	bd70      	pop	{r4, r5, r6, pc}
		char n_lo = ascii_buf[2*i+1];
 8000c9c:	780d      	ldrb	r5, [r1, #0]
		char n_hi = ascii_buf[2*i];
 8000c9e:	f811 4c01 	ldrb.w	r4, [r1, #-1]
		if(n_lo >= '0' && n_lo <= '9')
 8000ca2:	f1a5 0630 	sub.w	r6, r5, #48	; 0x30
 8000ca6:	b2f6      	uxtb	r6, r6
 8000ca8:	2e09      	cmp	r6, #9
 8000caa:	d80c      	bhi.n	8000cc6 <hex_decode+0x3a>
			data_buf[i] = n_lo - '0';
 8000cac:	701e      	strb	r6, [r3, #0]
		if(n_hi >= '0' && n_hi <= '9')
 8000cae:	f1a4 0530 	sub.w	r5, r4, #48	; 0x30
 8000cb2:	b2ee      	uxtb	r6, r5
 8000cb4:	2e09      	cmp	r6, #9
 8000cb6:	d815      	bhi.n	8000ce4 <hex_decode+0x58>
			data_buf[i] |= (n_hi - 'A' + 10) << 4;
 8000cb8:	781c      	ldrb	r4, [r3, #0]
 8000cba:	ea44 1405 	orr.w	r4, r4, r5, lsl #4
			data_buf[i] |= (n_hi - 'a' + 10) << 4;
 8000cbe:	701c      	strb	r4, [r3, #0]
 8000cc0:	3102      	adds	r1, #2
 8000cc2:	3301      	adds	r3, #1
 8000cc4:	e7e5      	b.n	8000c92 <hex_decode+0x6>
		else if(n_lo >= 'A' && n_lo <= 'F')
 8000cc6:	f1a5 0641 	sub.w	r6, r5, #65	; 0x41
 8000cca:	2e05      	cmp	r6, #5
 8000ccc:	d802      	bhi.n	8000cd4 <hex_decode+0x48>
			data_buf[i] = n_lo - 'A' + 10;
 8000cce:	3d37      	subs	r5, #55	; 0x37
			data_buf[i] = n_lo - 'a' + 10;
 8000cd0:	701d      	strb	r5, [r3, #0]
 8000cd2:	e7ec      	b.n	8000cae <hex_decode+0x22>
		else if(n_lo >= 'a' && n_lo <= 'f')
 8000cd4:	f1a5 0661 	sub.w	r6, r5, #97	; 0x61
 8000cd8:	2e05      	cmp	r6, #5
 8000cda:	d901      	bls.n	8000ce0 <hex_decode+0x54>
			return 1;
 8000cdc:	2001      	movs	r0, #1
 8000cde:	bd70      	pop	{r4, r5, r6, pc}
			data_buf[i] = n_lo - 'a' + 10;
 8000ce0:	3d57      	subs	r5, #87	; 0x57
 8000ce2:	e7f5      	b.n	8000cd0 <hex_decode+0x44>
		else if(n_hi >= 'A' && n_hi <= 'F')
 8000ce4:	f1a4 0541 	sub.w	r5, r4, #65	; 0x41
 8000ce8:	2d05      	cmp	r5, #5
 8000cea:	d802      	bhi.n	8000cf2 <hex_decode+0x66>
			data_buf[i] |= (n_hi - 'A' + 10) << 4;
 8000cec:	f1a4 0537 	sub.w	r5, r4, #55	; 0x37
 8000cf0:	e7e2      	b.n	8000cb8 <hex_decode+0x2c>
		else if(n_hi >= 'a' && n_hi <= 'f')
 8000cf2:	f1a4 0561 	sub.w	r5, r4, #97	; 0x61
 8000cf6:	2d05      	cmp	r5, #5
 8000cf8:	d8f0      	bhi.n	8000cdc <hex_decode+0x50>
			data_buf[i] |= (n_hi - 'a' + 10) << 4;
 8000cfa:	781d      	ldrb	r5, [r3, #0]
 8000cfc:	3c57      	subs	r4, #87	; 0x57
 8000cfe:	ea45 1404 	orr.w	r4, r5, r4, lsl #4
 8000d02:	e7dc      	b.n	8000cbe <hex_decode+0x32>

08000d04 <simpleserial_addcmd>:
{
	simpleserial_addcmd('v', 0, check_version);
}

int simpleserial_addcmd(char c, unsigned int len, uint8_t (*fp)(uint8_t*))
{
 8000d04:	b530      	push	{r4, r5, lr}
	if(num_commands >= MAX_SS_CMDS)
 8000d06:	4d09      	ldr	r5, [pc, #36]	; (8000d2c <simpleserial_addcmd+0x28>)
 8000d08:	682b      	ldr	r3, [r5, #0]
 8000d0a:	2b0f      	cmp	r3, #15
 8000d0c:	dc0b      	bgt.n	8000d26 <simpleserial_addcmd+0x22>
		return 1;

	if(len >= MAX_SS_LEN)
 8000d0e:	29bf      	cmp	r1, #191	; 0xbf
 8000d10:	d809      	bhi.n	8000d26 <simpleserial_addcmd+0x22>
		return 1;

	commands[num_commands].c   = c;
 8000d12:	240c      	movs	r4, #12
 8000d14:	fb04 5403 	mla	r4, r4, r3, r5
	commands[num_commands].len = len;
	commands[num_commands].fp  = fp;
	num_commands++;
 8000d18:	3301      	adds	r3, #1
	commands[num_commands].c   = c;
 8000d1a:	7120      	strb	r0, [r4, #4]
	commands[num_commands].len = len;
 8000d1c:	60a1      	str	r1, [r4, #8]
	commands[num_commands].fp  = fp;
 8000d1e:	60e2      	str	r2, [r4, #12]
	num_commands++;
 8000d20:	602b      	str	r3, [r5, #0]

	return 0;
 8000d22:	2000      	movs	r0, #0
 8000d24:	bd30      	pop	{r4, r5, pc}
		return 1;
 8000d26:	2001      	movs	r0, #1
}
 8000d28:	bd30      	pop	{r4, r5, pc}
 8000d2a:	bf00      	nop
 8000d2c:	2000044c 	.word	0x2000044c

08000d30 <simpleserial_init>:
	simpleserial_addcmd('v', 0, check_version);
 8000d30:	4a02      	ldr	r2, [pc, #8]	; (8000d3c <simpleserial_init+0xc>)
 8000d32:	2100      	movs	r1, #0
 8000d34:	2076      	movs	r0, #118	; 0x76
 8000d36:	f7ff bfe5 	b.w	8000d04 <simpleserial_addcmd>
 8000d3a:	bf00      	nop
 8000d3c:	08000c89 	.word	0x08000c89

08000d40 <simpleserial_put>:
	simpleserial_put('z', 1, ret);
#endif
}

void simpleserial_put(char c, uint8_t size, uint8_t* output)
{
 8000d40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000d44:	4615      	mov	r5, r2
 8000d46:	460f      	mov	r7, r1
	// Write first character
	putch(c);
 8000d48:	f000 f8f2 	bl	8000f30 <putch>

	// Write each byte as two nibbles
	for(int i = 0; i < size; i++)
	{
		putch(hex_lookup[output[i] >> 4 ]);
 8000d4c:	4e0c      	ldr	r6, [pc, #48]	; (8000d80 <simpleserial_put+0x40>)
	for(int i = 0; i < size; i++)
 8000d4e:	462c      	mov	r4, r5
 8000d50:	1b63      	subs	r3, r4, r5
 8000d52:	429f      	cmp	r7, r3
 8000d54:	dc04      	bgt.n	8000d60 <simpleserial_put+0x20>
		putch(hex_lookup[output[i] & 0xF]);
	}

	// Write trailing '\n'
	putch('\n');
 8000d56:	200a      	movs	r0, #10
}
 8000d58:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	putch('\n');
 8000d5c:	f000 b8e8 	b.w	8000f30 <putch>
 8000d60:	46a0      	mov	r8, r4
		putch(hex_lookup[output[i] >> 4 ]);
 8000d62:	f814 3b01 	ldrb.w	r3, [r4], #1
 8000d66:	091b      	lsrs	r3, r3, #4
 8000d68:	5cf0      	ldrb	r0, [r6, r3]
 8000d6a:	f000 f8e1 	bl	8000f30 <putch>
		putch(hex_lookup[output[i] & 0xF]);
 8000d6e:	f898 3000 	ldrb.w	r3, [r8]
 8000d72:	f003 030f 	and.w	r3, r3, #15
 8000d76:	5cf0      	ldrb	r0, [r6, r3]
 8000d78:	f000 f8da 	bl	8000f30 <putch>
 8000d7c:	e7e8      	b.n	8000d50 <simpleserial_put+0x10>
 8000d7e:	bf00      	nop
 8000d80:	08001834 	.word	0x08001834

08000d84 <simpleserial_get>:
{
 8000d84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	for(cmd = 0; cmd < num_commands; cmd++)
 8000d88:	4d22      	ldr	r5, [pc, #136]	; (8000e14 <simpleserial_get+0x90>)
{
 8000d8a:	f5ad 7d12 	sub.w	sp, sp, #584	; 0x248
	c = getch();
 8000d8e:	f000 f8bd 	bl	8000f0c <getch>
	for(cmd = 0; cmd < num_commands; cmd++)
 8000d92:	682b      	ldr	r3, [r5, #0]
 8000d94:	2400      	movs	r4, #0
		if(commands[cmd].c == c)
 8000d96:	1d2a      	adds	r2, r5, #4
 8000d98:	210c      	movs	r1, #12
	for(cmd = 0; cmd < num_commands; cmd++)
 8000d9a:	429c      	cmp	r4, r3
 8000d9c:	db04      	blt.n	8000da8 <simpleserial_get+0x24>
	if(cmd == num_commands)
 8000d9e:	d108      	bne.n	8000db2 <simpleserial_get+0x2e>
}
 8000da0:	f50d 7d12 	add.w	sp, sp, #584	; 0x248
 8000da4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if(commands[cmd].c == c)
 8000da8:	fb01 f604 	mul.w	r6, r1, r4
 8000dac:	5cb6      	ldrb	r6, [r6, r2]
 8000dae:	4286      	cmp	r6, r0
 8000db0:	d124      	bne.n	8000dfc <simpleserial_get+0x78>
	for(int i = 0; i < 2*commands[cmd].len; i++)
 8000db2:	270c      	movs	r7, #12
 8000db4:	2600      	movs	r6, #0
 8000db6:	fb07 5704 	mla	r7, r7, r4, r5
		ascii_buf[i] = c;
 8000dba:	f10d 08c8 	add.w	r8, sp, #200	; 0xc8
	for(int i = 0; i < 2*commands[cmd].len; i++)
 8000dbe:	68bb      	ldr	r3, [r7, #8]
 8000dc0:	ebb6 0f43 	cmp.w	r6, r3, lsl #1
 8000dc4:	d31c      	bcc.n	8000e00 <simpleserial_get+0x7c>
	c = getch();
 8000dc6:	f000 f8a1 	bl	8000f0c <getch>
	if(c != '\n' && c != '\r')
 8000dca:	280a      	cmp	r0, #10
 8000dcc:	d001      	beq.n	8000dd2 <simpleserial_get+0x4e>
 8000dce:	280d      	cmp	r0, #13
 8000dd0:	d1e6      	bne.n	8000da0 <simpleserial_get+0x1c>
	if(hex_decode(commands[cmd].len, ascii_buf, data_buf))
 8000dd2:	230c      	movs	r3, #12
 8000dd4:	fb03 5404 	mla	r4, r3, r4, r5
 8000dd8:	aa02      	add	r2, sp, #8
 8000dda:	a932      	add	r1, sp, #200	; 0xc8
 8000ddc:	68a0      	ldr	r0, [r4, #8]
 8000dde:	f7ff ff55 	bl	8000c8c <hex_decode>
 8000de2:	2800      	cmp	r0, #0
 8000de4:	d1dc      	bne.n	8000da0 <simpleserial_get+0x1c>
	ret[0] = commands[cmd].fp(data_buf);
 8000de6:	68e3      	ldr	r3, [r4, #12]
 8000de8:	a802      	add	r0, sp, #8
 8000dea:	4798      	blx	r3
	simpleserial_put('z', 1, ret);
 8000dec:	aa01      	add	r2, sp, #4
	ret[0] = commands[cmd].fp(data_buf);
 8000dee:	f88d 0004 	strb.w	r0, [sp, #4]
	simpleserial_put('z', 1, ret);
 8000df2:	2101      	movs	r1, #1
 8000df4:	207a      	movs	r0, #122	; 0x7a
 8000df6:	f7ff ffa3 	bl	8000d40 <simpleserial_put>
 8000dfa:	e7d1      	b.n	8000da0 <simpleserial_get+0x1c>
	for(cmd = 0; cmd < num_commands; cmd++)
 8000dfc:	3401      	adds	r4, #1
 8000dfe:	e7cc      	b.n	8000d9a <simpleserial_get+0x16>
		c = getch();
 8000e00:	f000 f884 	bl	8000f0c <getch>
		if(c == '\n' || c == '\r')
 8000e04:	280a      	cmp	r0, #10
 8000e06:	d0cb      	beq.n	8000da0 <simpleserial_get+0x1c>
 8000e08:	280d      	cmp	r0, #13
 8000e0a:	d0c9      	beq.n	8000da0 <simpleserial_get+0x1c>
		ascii_buf[i] = c;
 8000e0c:	f806 0008 	strb.w	r0, [r6, r8]
	for(int i = 0; i < 2*commands[cmd].len; i++)
 8000e10:	3601      	adds	r6, #1
 8000e12:	e7d4      	b.n	8000dbe <simpleserial_get+0x3a>
 8000e14:	2000044c 	.word	0x2000044c

08000e18 <platform_init>:

uint8_t hw_key[16];
static CRYP_HandleTypeDef cryp;

void platform_init(void)
{
 8000e18:	b510      	push	{r4, lr}
 8000e1a:	b092      	sub	sp, #72	; 0x48
     RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
     uint32_t flash_latency = 0;
     HAL_RCC_ClockConfig(&RCC_ClkInitStruct, flash_latency);
#else
	RCC_OscInitTypeDef RCC_OscInitStruct;
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI;
 8000e1c:	2303      	movs	r3, #3
	RCC_OscInitStruct.HSEState       = RCC_HSE_BYPASS;
	RCC_OscInitStruct.HSIState       = RCC_HSI_OFF;
 8000e1e:	2400      	movs	r4, #0
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI;
 8000e20:	9306      	str	r3, [sp, #24]
	RCC_OscInitStruct.PLL.PLLSource  = RCC_PLL_NONE;
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000e22:	a806      	add	r0, sp, #24
	RCC_OscInitStruct.HSEState       = RCC_HSE_BYPASS;
 8000e24:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
 8000e28:	9307      	str	r3, [sp, #28]
	RCC_OscInitStruct.HSIState       = RCC_HSI_OFF;
 8000e2a:	9409      	str	r4, [sp, #36]	; 0x24
	RCC_OscInitStruct.PLL.PLLSource  = RCC_PLL_NONE;
 8000e2c:	940d      	str	r4, [sp, #52]	; 0x34
	HAL_RCC_OscConfig(&RCC_OscInitStruct);
 8000e2e:	f000 f8a7 	bl	8000f80 <HAL_RCC_OscConfig>

	RCC_ClkInitTypeDef RCC_ClkInitStruct;
	RCC_ClkInitStruct.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
 8000e32:	230f      	movs	r3, #15
 8000e34:	9301      	str	r3, [sp, #4]
	RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_HSE;
	RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_ACR_LATENCY_5WS);
 8000e36:	2105      	movs	r1, #5
	RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_HSE;
 8000e38:	2301      	movs	r3, #1
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_ACR_LATENCY_5WS);
 8000e3a:	a801      	add	r0, sp, #4
	RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_HSE;
 8000e3c:	9302      	str	r3, [sp, #8]
	RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
 8000e3e:	9403      	str	r4, [sp, #12]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000e40:	9404      	str	r4, [sp, #16]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000e42:	9405      	str	r4, [sp, #20]
	HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_ACR_LATENCY_5WS);
 8000e44:	f000 fa30 	bl	80012a8 <HAL_RCC_ClockConfig>
#endif
}
 8000e48:	b012      	add	sp, #72	; 0x48
 8000e4a:	bd10      	pop	{r4, pc}

08000e4c <init_uart>:

void init_uart(void)
{
 8000e4c:	b530      	push	{r4, r5, lr}
 8000e4e:	b089      	sub	sp, #36	; 0x24
	GPIO_InitTypeDef GpioInit;
	GpioInit.Pin       = GPIO_PIN_9 | GPIO_PIN_10;
 8000e50:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8000e54:	9303      	str	r3, [sp, #12]
	GpioInit.Mode      = GPIO_MODE_AF_PP;
 8000e56:	2302      	movs	r3, #2
	GpioInit.Pull      = GPIO_PULLUP;
	GpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
	GpioInit.Alternate = GPIO_AF7_USART1;
	__GPIOA_CLK_ENABLE();
 8000e58:	2500      	movs	r5, #0
 8000e5a:	4c16      	ldr	r4, [pc, #88]	; (8000eb4 <init_uart+0x68>)
	GpioInit.Mode      = GPIO_MODE_AF_PP;
 8000e5c:	9304      	str	r3, [sp, #16]
	GpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
 8000e5e:	9306      	str	r3, [sp, #24]
	GpioInit.Pull      = GPIO_PULLUP;
 8000e60:	2201      	movs	r2, #1
	GpioInit.Alternate = GPIO_AF7_USART1;
 8000e62:	2307      	movs	r3, #7
	__GPIOA_CLK_ENABLE();
 8000e64:	9501      	str	r5, [sp, #4]
	GpioInit.Pull      = GPIO_PULLUP;
 8000e66:	9205      	str	r2, [sp, #20]
	GpioInit.Alternate = GPIO_AF7_USART1;
 8000e68:	9307      	str	r3, [sp, #28]
	__GPIOA_CLK_ENABLE();
 8000e6a:	6b23      	ldr	r3, [r4, #48]	; 0x30
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8000e6c:	4812      	ldr	r0, [pc, #72]	; (8000eb8 <init_uart+0x6c>)
	__GPIOA_CLK_ENABLE();
 8000e6e:	4313      	orrs	r3, r2
 8000e70:	6323      	str	r3, [r4, #48]	; 0x30
 8000e72:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000e74:	4013      	ands	r3, r2
 8000e76:	9301      	str	r3, [sp, #4]
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8000e78:	a903      	add	r1, sp, #12
	__GPIOA_CLK_ENABLE();
 8000e7a:	9b01      	ldr	r3, [sp, #4]
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8000e7c:	f000 faac 	bl	80013d8 <HAL_GPIO_Init>

	UartHandle.Instance        = USART1;
 8000e80:	480e      	ldr	r0, [pc, #56]	; (8000ebc <init_uart+0x70>)
  #if SS_VER==SS_VER_2_0
  UartHandle.Init.BaudRate   = 230400;
  #else
  UartHandle.Init.BaudRate   = 38400;
 8000e82:	4a0f      	ldr	r2, [pc, #60]	; (8000ec0 <init_uart+0x74>)
	UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
	UartHandle.Init.StopBits   = UART_STOPBITS_1;
	UartHandle.Init.Parity     = UART_PARITY_NONE;
	UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
	UartHandle.Init.Mode       = UART_MODE_TX_RX;
	__USART1_CLK_ENABLE();
 8000e84:	9502      	str	r5, [sp, #8]
  UartHandle.Init.BaudRate   = 38400;
 8000e86:	f44f 4316 	mov.w	r3, #38400	; 0x9600
 8000e8a:	e880 000c 	stmia.w	r0, {r2, r3}
	UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8000e8e:	230c      	movs	r3, #12
	UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 8000e90:	6085      	str	r5, [r0, #8]
	UartHandle.Init.StopBits   = UART_STOPBITS_1;
 8000e92:	60c5      	str	r5, [r0, #12]
	UartHandle.Init.Parity     = UART_PARITY_NONE;
 8000e94:	6105      	str	r5, [r0, #16]
	UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
 8000e96:	6185      	str	r5, [r0, #24]
	UartHandle.Init.Mode       = UART_MODE_TX_RX;
 8000e98:	6143      	str	r3, [r0, #20]
	__USART1_CLK_ENABLE();
 8000e9a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000e9c:	f043 0310 	orr.w	r3, r3, #16
 8000ea0:	6463      	str	r3, [r4, #68]	; 0x44
 8000ea2:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000ea4:	f003 0310 	and.w	r3, r3, #16
 8000ea8:	9302      	str	r3, [sp, #8]
 8000eaa:	9b02      	ldr	r3, [sp, #8]
	HAL_UART_Init(&UartHandle);
 8000eac:	f000 fb7a 	bl	80015a4 <HAL_UART_Init>
}
 8000eb0:	b009      	add	sp, #36	; 0x24
 8000eb2:	bd30      	pop	{r4, r5, pc}
 8000eb4:	40023800 	.word	0x40023800
 8000eb8:	40020000 	.word	0x40020000
 8000ebc:	20000524 	.word	0x20000524
 8000ec0:	40011000 	.word	0x40011000

08000ec4 <trigger_setup>:

//#define STM32F4_WLCSP

void trigger_setup(void)
{
 8000ec4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	GpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
    __GPIOD_CLK_ENABLE();
    HAL_GPIO_Init(GPIOD, &GpioInit);   
#else
	GPIO_InitTypeDef GpioInit;
	GpioInit.Pin       = GPIO_PIN_12;
 8000ec6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000eca:	9301      	str	r3, [sp, #4]
	GpioInit.Mode      = GPIO_MODE_OUTPUT_PP;
 8000ecc:	2301      	movs	r3, #1
 8000ece:	9302      	str	r3, [sp, #8]
	GpioInit.Pull      = GPIO_NOPULL;
 8000ed0:	2300      	movs	r3, #0
 8000ed2:	9303      	str	r3, [sp, #12]
	GpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8000ed4:	a901      	add	r1, sp, #4
	GpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
 8000ed6:	2302      	movs	r3, #2
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8000ed8:	4803      	ldr	r0, [pc, #12]	; (8000ee8 <trigger_setup+0x24>)
	GpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
 8000eda:	9304      	str	r3, [sp, #16]
	HAL_GPIO_Init(GPIOA, &GpioInit);
 8000edc:	f000 fa7c 	bl	80013d8 <HAL_GPIO_Init>
#endif
}
 8000ee0:	b007      	add	sp, #28
 8000ee2:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ee6:	bf00      	nop
 8000ee8:	40020000 	.word	0x40020000

08000eec <trigger_high>:
void trigger_high(void)
{
#ifdef STM32F4_WLCSP
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, SET);
#else
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, SET);
 8000eec:	2201      	movs	r2, #1
 8000eee:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000ef2:	4801      	ldr	r0, [pc, #4]	; (8000ef8 <trigger_high+0xc>)
 8000ef4:	f000 bb50 	b.w	8001598 <HAL_GPIO_WritePin>
 8000ef8:	40020000 	.word	0x40020000

08000efc <trigger_low>:
void trigger_low(void)
{
#ifdef STM32F4_WLCSP
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_4, RESET);
#else
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, RESET);
 8000efc:	2200      	movs	r2, #0
 8000efe:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8000f02:	4801      	ldr	r0, [pc, #4]	; (8000f08 <trigger_low+0xc>)
 8000f04:	f000 bb48 	b.w	8001598 <HAL_GPIO_WritePin>
 8000f08:	40020000 	.word	0x40020000

08000f0c <getch>:
#endif
}
char getch(void)
{
 8000f0c:	b513      	push	{r0, r1, r4, lr}
	uint8_t d;
	while (HAL_UART_Receive(&UartHandle, &d, 1, 5000) != HAL_OK);
 8000f0e:	4c07      	ldr	r4, [pc, #28]	; (8000f2c <getch+0x20>)
 8000f10:	f241 3388 	movw	r3, #5000	; 0x1388
 8000f14:	2201      	movs	r2, #1
 8000f16:	f10d 0107 	add.w	r1, sp, #7
 8000f1a:	4620      	mov	r0, r4
 8000f1c:	f000 fc03 	bl	8001726 <HAL_UART_Receive>
 8000f20:	2800      	cmp	r0, #0
 8000f22:	d1f5      	bne.n	8000f10 <getch+0x4>
	return d;
}
 8000f24:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8000f28:	b002      	add	sp, #8
 8000f2a:	bd10      	pop	{r4, pc}
 8000f2c:	20000524 	.word	0x20000524

08000f30 <putch>:

void putch(char c)
{
 8000f30:	b507      	push	{r0, r1, r2, lr}
	uint8_t d  = c;
 8000f32:	a902      	add	r1, sp, #8
	HAL_UART_Transmit(&UartHandle,  &d, 1, 5000);
 8000f34:	f241 3388 	movw	r3, #5000	; 0x1388
	uint8_t d  = c;
 8000f38:	f801 0d01 	strb.w	r0, [r1, #-1]!
	HAL_UART_Transmit(&UartHandle,  &d, 1, 5000);
 8000f3c:	2201      	movs	r2, #1
 8000f3e:	4803      	ldr	r0, [pc, #12]	; (8000f4c <putch+0x1c>)
 8000f40:	f000 fbae 	bl	80016a0 <HAL_UART_Transmit>
}
 8000f44:	b003      	add	sp, #12
 8000f46:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f4a:	bf00      	nop
 8000f4c:	20000524 	.word	0x20000524

08000f50 <init_fpu>:
}

void init_fpu(void)
{
	// set configurable flag on FPU - maybe not necessary?
	SCB->CPACR |= 0x00f00000; //fpu can be configured
 8000f50:	4b06      	ldr	r3, [pc, #24]	; (8000f6c <init_fpu+0x1c>)
 8000f52:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8000f56:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000f5a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	/* set CP10 and CP11 Full Access */
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));
 8000f5e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8000f62:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000f66:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 8000f6a:	4770      	bx	lr
 8000f6c:	e000ed00 	.word	0xe000ed00

08000f70 <HAL_GetTick>:


uint32_t HAL_GetTick(void)
{
	static uint32_t tick;
	return tick++;;
 8000f70:	4b02      	ldr	r3, [pc, #8]	; (8000f7c <HAL_GetTick+0xc>)
 8000f72:	6818      	ldr	r0, [r3, #0]
 8000f74:	1c42      	adds	r2, r0, #1
 8000f76:	601a      	str	r2, [r3, #0]
}
 8000f78:	4770      	bx	lr
 8000f7a:	bf00      	nop
 8000f7c:	20000510 	.word	0x20000510

08000f80 <HAL_RCC_OscConfig>:
  uint32_t tickstart = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000f80:	6803      	ldr	r3, [r0, #0]
{
 8000f82:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000f84:	07dc      	lsls	r4, r3, #31
{
 8000f86:	4601      	mov	r1, r0
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000f88:	d43b      	bmi.n	8001002 <HAL_RCC_OscConfig+0x82>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000f8a:	680b      	ldr	r3, [r1, #0]
 8000f8c:	0798      	lsls	r0, r3, #30
 8000f8e:	f100 8086 	bmi.w	800109e <HAL_RCC_OscConfig+0x11e>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8000f92:	680b      	ldr	r3, [r1, #0]
 8000f94:	071b      	lsls	r3, r3, #28
 8000f96:	f100 80d1 	bmi.w	800113c <HAL_RCC_OscConfig+0x1bc>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8000f9a:	680b      	ldr	r3, [r1, #0]
 8000f9c:	075f      	lsls	r7, r3, #29
 8000f9e:	d52a      	bpl.n	8000ff6 <HAL_RCC_OscConfig+0x76>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8000fa0:	2300      	movs	r3, #0
 8000fa2:	9301      	str	r3, [sp, #4]
 8000fa4:	4b8e      	ldr	r3, [pc, #568]	; (80011e0 <HAL_RCC_OscConfig+0x260>)

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8000fa6:	4c8f      	ldr	r4, [pc, #572]	; (80011e4 <HAL_RCC_OscConfig+0x264>)
    __HAL_RCC_PWR_CLK_ENABLE();
 8000fa8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000faa:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000fae:	641a      	str	r2, [r3, #64]	; 0x40
 8000fb0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000fb2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000fb6:	9301      	str	r3, [sp, #4]
 8000fb8:	9b01      	ldr	r3, [sp, #4]
    PWR->CR |= PWR_CR_DBP;
 8000fba:	6823      	ldr	r3, [r4, #0]
 8000fbc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000fc0:	6023      	str	r3, [r4, #0]

    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 8000fc2:	f7ff ffd5 	bl	8000f70 <HAL_GetTick>
 8000fc6:	4605      	mov	r5, r0

    while((PWR->CR & PWR_CR_DBP) == RESET)
 8000fc8:	6823      	ldr	r3, [r4, #0]
 8000fca:	05da      	lsls	r2, r3, #23
 8000fcc:	f140 80d8 	bpl.w	8001180 <HAL_RCC_OscConfig+0x200>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8000fd0:	688b      	ldr	r3, [r1, #8]
 8000fd2:	4c83      	ldr	r4, [pc, #524]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
 8000fd4:	2b01      	cmp	r3, #1
 8000fd6:	f040 80da 	bne.w	800118e <HAL_RCC_OscConfig+0x20e>
 8000fda:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8000fdc:	f043 0301 	orr.w	r3, r3, #1
 8000fe0:	6723      	str	r3, [r4, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8000fe2:	f7ff ffc5 	bl	8000f70 <HAL_GetTick>

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000fe6:	4c7e      	ldr	r4, [pc, #504]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
      tickstart = HAL_GetTick();
 8000fe8:	4605      	mov	r5, r0
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8000fea:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8000fee:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8000ff0:	079b      	lsls	r3, r3, #30
 8000ff2:	f140 80ed 	bpl.w	80011d0 <HAL_RCC_OscConfig+0x250>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8000ff6:	698a      	ldr	r2, [r1, #24]
 8000ff8:	2a00      	cmp	r2, #0
 8000ffa:	f040 80f9 	bne.w	80011f0 <HAL_RCC_OscConfig+0x270>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 8000ffe:	2000      	movs	r0, #0
 8001000:	e015      	b.n	800102e <HAL_RCC_OscConfig+0xae>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001002:	4b77      	ldr	r3, [pc, #476]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
 8001004:	689a      	ldr	r2, [r3, #8]
 8001006:	f002 020c 	and.w	r2, r2, #12
 800100a:	2a04      	cmp	r2, #4
 800100c:	d007      	beq.n	800101e <HAL_RCC_OscConfig+0x9e>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800100e:	689a      	ldr	r2, [r3, #8]
 8001010:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8001014:	2a08      	cmp	r2, #8
 8001016:	d10c      	bne.n	8001032 <HAL_RCC_OscConfig+0xb2>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8001018:	685b      	ldr	r3, [r3, #4]
 800101a:	025a      	lsls	r2, r3, #9
 800101c:	d509      	bpl.n	8001032 <HAL_RCC_OscConfig+0xb2>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800101e:	4b70      	ldr	r3, [pc, #448]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
 8001020:	681b      	ldr	r3, [r3, #0]
 8001022:	039b      	lsls	r3, r3, #14
 8001024:	d5b1      	bpl.n	8000f8a <HAL_RCC_OscConfig+0xa>
 8001026:	684b      	ldr	r3, [r1, #4]
 8001028:	2b00      	cmp	r3, #0
 800102a:	d1ae      	bne.n	8000f8a <HAL_RCC_OscConfig+0xa>
        return HAL_ERROR;
 800102c:	2001      	movs	r0, #1
}
 800102e:	b003      	add	sp, #12
 8001030:	bdf0      	pop	{r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001032:	684b      	ldr	r3, [r1, #4]
 8001034:	4c6a      	ldr	r4, [pc, #424]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
 8001036:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800103a:	d111      	bne.n	8001060 <HAL_RCC_OscConfig+0xe0>
 800103c:	6823      	ldr	r3, [r4, #0]
 800103e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001042:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8001044:	f7ff ff94 	bl	8000f70 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001048:	4c65      	ldr	r4, [pc, #404]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
        tickstart = HAL_GetTick();
 800104a:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800104c:	6823      	ldr	r3, [r4, #0]
 800104e:	039f      	lsls	r7, r3, #14
 8001050:	d49b      	bmi.n	8000f8a <HAL_RCC_OscConfig+0xa>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001052:	f7ff ff8d 	bl	8000f70 <HAL_GetTick>
 8001056:	1b40      	subs	r0, r0, r5
 8001058:	2864      	cmp	r0, #100	; 0x64
 800105a:	d9f7      	bls.n	800104c <HAL_RCC_OscConfig+0xcc>
            return HAL_TIMEOUT;
 800105c:	2003      	movs	r0, #3
 800105e:	e7e6      	b.n	800102e <HAL_RCC_OscConfig+0xae>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001060:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8001064:	d104      	bne.n	8001070 <HAL_RCC_OscConfig+0xf0>
 8001066:	6823      	ldr	r3, [r4, #0]
 8001068:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800106c:	6023      	str	r3, [r4, #0]
 800106e:	e7e5      	b.n	800103c <HAL_RCC_OscConfig+0xbc>
 8001070:	6822      	ldr	r2, [r4, #0]
 8001072:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001076:	6022      	str	r2, [r4, #0]
 8001078:	6822      	ldr	r2, [r4, #0]
 800107a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800107e:	6022      	str	r2, [r4, #0]
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8001080:	2b00      	cmp	r3, #0
 8001082:	d1df      	bne.n	8001044 <HAL_RCC_OscConfig+0xc4>
        tickstart = HAL_GetTick();
 8001084:	f7ff ff74 	bl	8000f70 <HAL_GetTick>
 8001088:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800108a:	6823      	ldr	r3, [r4, #0]
 800108c:	039e      	lsls	r6, r3, #14
 800108e:	f57f af7c 	bpl.w	8000f8a <HAL_RCC_OscConfig+0xa>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001092:	f7ff ff6d 	bl	8000f70 <HAL_GetTick>
 8001096:	1b40      	subs	r0, r0, r5
 8001098:	2864      	cmp	r0, #100	; 0x64
 800109a:	d9f6      	bls.n	800108a <HAL_RCC_OscConfig+0x10a>
 800109c:	e7de      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800109e:	4b50      	ldr	r3, [pc, #320]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
 80010a0:	689a      	ldr	r2, [r3, #8]
 80010a2:	f012 0f0c 	tst.w	r2, #12
 80010a6:	d007      	beq.n	80010b8 <HAL_RCC_OscConfig+0x138>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80010a8:	689a      	ldr	r2, [r3, #8]
 80010aa:	f002 020c 	and.w	r2, r2, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 80010ae:	2a08      	cmp	r2, #8
 80010b0:	d116      	bne.n	80010e0 <HAL_RCC_OscConfig+0x160>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80010b2:	685b      	ldr	r3, [r3, #4]
 80010b4:	025d      	lsls	r5, r3, #9
 80010b6:	d413      	bmi.n	80010e0 <HAL_RCC_OscConfig+0x160>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80010b8:	4b49      	ldr	r3, [pc, #292]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
 80010ba:	681a      	ldr	r2, [r3, #0]
 80010bc:	0794      	lsls	r4, r2, #30
 80010be:	d502      	bpl.n	80010c6 <HAL_RCC_OscConfig+0x146>
 80010c0:	68ca      	ldr	r2, [r1, #12]
 80010c2:	2a01      	cmp	r2, #1
 80010c4:	d1b2      	bne.n	800102c <HAL_RCC_OscConfig+0xac>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80010c6:	681c      	ldr	r4, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80010c8:	22f8      	movs	r2, #248	; 0xf8
 80010ca:	fa92 f2a2 	rbit	r2, r2
 80010ce:	fab2 f082 	clz	r0, r2
 80010d2:	690a      	ldr	r2, [r1, #16]
 80010d4:	4082      	lsls	r2, r0
 80010d6:	f024 00f8 	bic.w	r0, r4, #248	; 0xf8
 80010da:	4302      	orrs	r2, r0
 80010dc:	601a      	str	r2, [r3, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80010de:	e758      	b.n	8000f92 <HAL_RCC_OscConfig+0x12>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80010e0:	68ca      	ldr	r2, [r1, #12]
 80010e2:	4b41      	ldr	r3, [pc, #260]	; (80011e8 <HAL_RCC_OscConfig+0x268>)
 80010e4:	b1da      	cbz	r2, 800111e <HAL_RCC_OscConfig+0x19e>
        __HAL_RCC_HSI_ENABLE();
 80010e6:	2201      	movs	r2, #1
 80010e8:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80010ea:	f7ff ff41 	bl	8000f70 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80010ee:	4c3c      	ldr	r4, [pc, #240]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
        tickstart = HAL_GetTick();
 80010f0:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80010f2:	6823      	ldr	r3, [r4, #0]
 80010f4:	0798      	lsls	r0, r3, #30
 80010f6:	d50c      	bpl.n	8001112 <HAL_RCC_OscConfig+0x192>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80010f8:	6820      	ldr	r0, [r4, #0]
 80010fa:	23f8      	movs	r3, #248	; 0xf8
 80010fc:	fa93 f3a3 	rbit	r3, r3
 8001100:	fab3 f283 	clz	r2, r3
 8001104:	690b      	ldr	r3, [r1, #16]
 8001106:	4093      	lsls	r3, r2
 8001108:	f020 02f8 	bic.w	r2, r0, #248	; 0xf8
 800110c:	4313      	orrs	r3, r2
 800110e:	6023      	str	r3, [r4, #0]
 8001110:	e73f      	b.n	8000f92 <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001112:	f7ff ff2d 	bl	8000f70 <HAL_GetTick>
 8001116:	1b40      	subs	r0, r0, r5
 8001118:	2802      	cmp	r0, #2
 800111a:	d9ea      	bls.n	80010f2 <HAL_RCC_OscConfig+0x172>
 800111c:	e79e      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
        __HAL_RCC_HSI_DISABLE();
 800111e:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001120:	f7ff ff26 	bl	8000f70 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001124:	4c2e      	ldr	r4, [pc, #184]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
        tickstart = HAL_GetTick();
 8001126:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001128:	6823      	ldr	r3, [r4, #0]
 800112a:	079a      	lsls	r2, r3, #30
 800112c:	f57f af31 	bpl.w	8000f92 <HAL_RCC_OscConfig+0x12>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001130:	f7ff ff1e 	bl	8000f70 <HAL_GetTick>
 8001134:	1b40      	subs	r0, r0, r5
 8001136:	2802      	cmp	r0, #2
 8001138:	d9f6      	bls.n	8001128 <HAL_RCC_OscConfig+0x1a8>
 800113a:	e78f      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800113c:	694a      	ldr	r2, [r1, #20]
 800113e:	4b2b      	ldr	r3, [pc, #172]	; (80011ec <HAL_RCC_OscConfig+0x26c>)
 8001140:	b17a      	cbz	r2, 8001162 <HAL_RCC_OscConfig+0x1e2>
      __HAL_RCC_LSI_ENABLE();
 8001142:	2201      	movs	r2, #1
 8001144:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001146:	f7ff ff13 	bl	8000f70 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800114a:	4c25      	ldr	r4, [pc, #148]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
      tickstart = HAL_GetTick();
 800114c:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800114e:	6f63      	ldr	r3, [r4, #116]	; 0x74
 8001150:	079e      	lsls	r6, r3, #30
 8001152:	f53f af22 	bmi.w	8000f9a <HAL_RCC_OscConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001156:	f7ff ff0b 	bl	8000f70 <HAL_GetTick>
 800115a:	1b40      	subs	r0, r0, r5
 800115c:	2802      	cmp	r0, #2
 800115e:	d9f6      	bls.n	800114e <HAL_RCC_OscConfig+0x1ce>
 8001160:	e77c      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
      __HAL_RCC_LSI_DISABLE();
 8001162:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001164:	f7ff ff04 	bl	8000f70 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001168:	4c1d      	ldr	r4, [pc, #116]	; (80011e0 <HAL_RCC_OscConfig+0x260>)
      tickstart = HAL_GetTick();
 800116a:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800116c:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800116e:	0798      	lsls	r0, r3, #30
 8001170:	f57f af13 	bpl.w	8000f9a <HAL_RCC_OscConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001174:	f7ff fefc 	bl	8000f70 <HAL_GetTick>
 8001178:	1b40      	subs	r0, r0, r5
 800117a:	2802      	cmp	r0, #2
 800117c:	d9f6      	bls.n	800116c <HAL_RCC_OscConfig+0x1ec>
 800117e:	e76d      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8001180:	f7ff fef6 	bl	8000f70 <HAL_GetTick>
 8001184:	1b40      	subs	r0, r0, r5
 8001186:	2802      	cmp	r0, #2
 8001188:	f67f af1e 	bls.w	8000fc8 <HAL_RCC_OscConfig+0x48>
 800118c:	e766      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800118e:	2b05      	cmp	r3, #5
 8001190:	d104      	bne.n	800119c <HAL_RCC_OscConfig+0x21c>
 8001192:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8001194:	f043 0304 	orr.w	r3, r3, #4
 8001198:	6723      	str	r3, [r4, #112]	; 0x70
 800119a:	e71e      	b.n	8000fda <HAL_RCC_OscConfig+0x5a>
 800119c:	6f22      	ldr	r2, [r4, #112]	; 0x70
 800119e:	f022 0201 	bic.w	r2, r2, #1
 80011a2:	6722      	str	r2, [r4, #112]	; 0x70
 80011a4:	6f22      	ldr	r2, [r4, #112]	; 0x70
 80011a6:	f022 0204 	bic.w	r2, r2, #4
 80011aa:	6722      	str	r2, [r4, #112]	; 0x70
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80011ac:	2b00      	cmp	r3, #0
 80011ae:	f47f af18 	bne.w	8000fe2 <HAL_RCC_OscConfig+0x62>
      tickstart = HAL_GetTick();
 80011b2:	f7ff fedd 	bl	8000f70 <HAL_GetTick>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80011b6:	f241 3688 	movw	r6, #5000	; 0x1388
      tickstart = HAL_GetTick();
 80011ba:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80011bc:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80011be:	079f      	lsls	r7, r3, #30
 80011c0:	f57f af19 	bpl.w	8000ff6 <HAL_RCC_OscConfig+0x76>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80011c4:	f7ff fed4 	bl	8000f70 <HAL_GetTick>
 80011c8:	1b40      	subs	r0, r0, r5
 80011ca:	42b0      	cmp	r0, r6
 80011cc:	d9f6      	bls.n	80011bc <HAL_RCC_OscConfig+0x23c>
 80011ce:	e745      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80011d0:	f7ff fece 	bl	8000f70 <HAL_GetTick>
 80011d4:	1b40      	subs	r0, r0, r5
 80011d6:	42b0      	cmp	r0, r6
 80011d8:	f67f af09 	bls.w	8000fee <HAL_RCC_OscConfig+0x6e>
 80011dc:	e73e      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
 80011de:	bf00      	nop
 80011e0:	40023800 	.word	0x40023800
 80011e4:	40007000 	.word	0x40007000
 80011e8:	42470000 	.word	0x42470000
 80011ec:	42470e80 	.word	0x42470e80
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 80011f0:	4c2b      	ldr	r4, [pc, #172]	; (80012a0 <HAL_RCC_OscConfig+0x320>)
 80011f2:	68a3      	ldr	r3, [r4, #8]
 80011f4:	f003 030c 	and.w	r3, r3, #12
 80011f8:	2b08      	cmp	r3, #8
 80011fa:	f43f af17 	beq.w	800102c <HAL_RCC_OscConfig+0xac>
 80011fe:	4d29      	ldr	r5, [pc, #164]	; (80012a4 <HAL_RCC_OscConfig+0x324>)
 8001200:	2300      	movs	r3, #0
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001202:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 8001204:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001206:	d13e      	bne.n	8001286 <HAL_RCC_OscConfig+0x306>
        tickstart = HAL_GetTick();
 8001208:	f7ff feb2 	bl	8000f70 <HAL_GetTick>
 800120c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800120e:	6823      	ldr	r3, [r4, #0]
 8001210:	0198      	lsls	r0, r3, #6
 8001212:	d432      	bmi.n	800127a <HAL_RCC_OscConfig+0x2fa>
 8001214:	f647 77c0 	movw	r7, #32704	; 0x7fc0
 8001218:	fa97 f7a7 	rbit	r7, r7
 800121c:	f44f 3240 	mov.w	r2, #196608	; 0x30000
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001220:	fab7 f787 	clz	r7, r7
 8001224:	fa92 f2a2 	rbit	r2, r2
 8001228:	f04f 6070 	mov.w	r0, #251658240	; 0xf000000
 800122c:	fab2 f682 	clz	r6, r2
 8001230:	fa90 f0a0 	rbit	r0, r0
 8001234:	6a0a      	ldr	r2, [r1, #32]
 8001236:	69cb      	ldr	r3, [r1, #28]
 8001238:	4313      	orrs	r3, r2
 800123a:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 800123c:	fa02 f707 	lsl.w	r7, r2, r7
 8001240:	6a8a      	ldr	r2, [r1, #40]	; 0x28
 8001242:	0852      	lsrs	r2, r2, #1
 8001244:	3a01      	subs	r2, #1
 8001246:	40b2      	lsls	r2, r6
 8001248:	433b      	orrs	r3, r7
 800124a:	4313      	orrs	r3, r2
 800124c:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 800124e:	fab0 f080 	clz	r0, r0
 8001252:	fa02 f000 	lsl.w	r0, r2, r0
 8001256:	4303      	orrs	r3, r0
 8001258:	6063      	str	r3, [r4, #4]
        __HAL_RCC_PLL_ENABLE();
 800125a:	2301      	movs	r3, #1
 800125c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800125e:	f7ff fe87 	bl	8000f70 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001262:	490f      	ldr	r1, [pc, #60]	; (80012a0 <HAL_RCC_OscConfig+0x320>)
        tickstart = HAL_GetTick();
 8001264:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001266:	680b      	ldr	r3, [r1, #0]
 8001268:	019a      	lsls	r2, r3, #6
 800126a:	f53f aec8 	bmi.w	8000ffe <HAL_RCC_OscConfig+0x7e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800126e:	f7ff fe7f 	bl	8000f70 <HAL_GetTick>
 8001272:	1b00      	subs	r0, r0, r4
 8001274:	2802      	cmp	r0, #2
 8001276:	d9f6      	bls.n	8001266 <HAL_RCC_OscConfig+0x2e6>
 8001278:	e6f0      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800127a:	f7ff fe79 	bl	8000f70 <HAL_GetTick>
 800127e:	1b80      	subs	r0, r0, r6
 8001280:	2802      	cmp	r0, #2
 8001282:	d9c4      	bls.n	800120e <HAL_RCC_OscConfig+0x28e>
 8001284:	e6ea      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
        tickstart = HAL_GetTick();
 8001286:	f7ff fe73 	bl	8000f70 <HAL_GetTick>
 800128a:	4601      	mov	r1, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800128c:	6823      	ldr	r3, [r4, #0]
 800128e:	019b      	lsls	r3, r3, #6
 8001290:	f57f aeb5 	bpl.w	8000ffe <HAL_RCC_OscConfig+0x7e>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001294:	f7ff fe6c 	bl	8000f70 <HAL_GetTick>
 8001298:	1a40      	subs	r0, r0, r1
 800129a:	2802      	cmp	r0, #2
 800129c:	d9f6      	bls.n	800128c <HAL_RCC_OscConfig+0x30c>
 800129e:	e6dd      	b.n	800105c <HAL_RCC_OscConfig+0xdc>
 80012a0:	40023800 	.word	0x40023800
 80012a4:	42470060 	.word	0x42470060

080012a8 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80012a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80012aa:	4b49      	ldr	r3, [pc, #292]	; (80013d0 <HAL_RCC_ClockConfig+0x128>)
 80012ac:	681a      	ldr	r2, [r3, #0]
 80012ae:	f002 020f 	and.w	r2, r2, #15
 80012b2:	428a      	cmp	r2, r1
{
 80012b4:	4605      	mov	r5, r0
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80012b6:	d31a      	bcc.n	80012ee <HAL_RCC_ClockConfig+0x46>
      return HAL_ERROR;
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80012b8:	682a      	ldr	r2, [r5, #0]
 80012ba:	0790      	lsls	r0, r2, #30
 80012bc:	d420      	bmi.n	8001300 <HAL_RCC_ClockConfig+0x58>
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80012be:	07d2      	lsls	r2, r2, #31
 80012c0:	d426      	bmi.n	8001310 <HAL_RCC_ClockConfig+0x68>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80012c2:	4b43      	ldr	r3, [pc, #268]	; (80013d0 <HAL_RCC_ClockConfig+0x128>)
 80012c4:	681a      	ldr	r2, [r3, #0]
 80012c6:	f002 020f 	and.w	r2, r2, #15
 80012ca:	4291      	cmp	r1, r2
 80012cc:	d370      	bcc.n	80013b0 <HAL_RCC_ClockConfig+0x108>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80012ce:	6828      	ldr	r0, [r5, #0]
 80012d0:	0743      	lsls	r3, r0, #29
 80012d2:	d475      	bmi.n	80013c0 <HAL_RCC_ClockConfig+0x118>
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80012d4:	f010 0008 	ands.w	r0, r0, #8
 80012d8:	d008      	beq.n	80012ec <HAL_RCC_ClockConfig+0x44>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80012da:	4a3e      	ldr	r2, [pc, #248]	; (80013d4 <HAL_RCC_ClockConfig+0x12c>)
 80012dc:	6929      	ldr	r1, [r5, #16]
 80012de:	6893      	ldr	r3, [r2, #8]
 80012e0:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 80012e4:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80012e8:	6093      	str	r3, [r2, #8]
  //SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];

  /* Configure the source of time base considering new system clocks settings*/
  //HAL_InitTick (TICK_INT_PRIORITY);

  return HAL_OK;
 80012ea:	2000      	movs	r0, #0
}
 80012ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 80012ee:	b2ca      	uxtb	r2, r1
 80012f0:	701a      	strb	r2, [r3, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80012f2:	681b      	ldr	r3, [r3, #0]
 80012f4:	f003 030f 	and.w	r3, r3, #15
 80012f8:	4299      	cmp	r1, r3
 80012fa:	d0dd      	beq.n	80012b8 <HAL_RCC_ClockConfig+0x10>
      return HAL_ERROR;
 80012fc:	2001      	movs	r0, #1
 80012fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001300:	4834      	ldr	r0, [pc, #208]	; (80013d4 <HAL_RCC_ClockConfig+0x12c>)
 8001302:	68ac      	ldr	r4, [r5, #8]
 8001304:	6883      	ldr	r3, [r0, #8]
 8001306:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800130a:	4323      	orrs	r3, r4
 800130c:	6083      	str	r3, [r0, #8]
 800130e:	e7d6      	b.n	80012be <HAL_RCC_ClockConfig+0x16>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001310:	686a      	ldr	r2, [r5, #4]
 8001312:	4b30      	ldr	r3, [pc, #192]	; (80013d4 <HAL_RCC_ClockConfig+0x12c>)
 8001314:	2a01      	cmp	r2, #1
 8001316:	d11d      	bne.n	8001354 <HAL_RCC_ClockConfig+0xac>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001318:	681b      	ldr	r3, [r3, #0]
 800131a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800131e:	d0ed      	beq.n	80012fc <HAL_RCC_ClockConfig+0x54>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001320:	4c2c      	ldr	r4, [pc, #176]	; (80013d4 <HAL_RCC_ClockConfig+0x12c>)
 8001322:	68a3      	ldr	r3, [r4, #8]
 8001324:	f023 0303 	bic.w	r3, r3, #3
 8001328:	4313      	orrs	r3, r2
 800132a:	60a3      	str	r3, [r4, #8]
    tickstart = HAL_GetTick();
 800132c:	f7ff fe20 	bl	8000f70 <HAL_GetTick>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001330:	686b      	ldr	r3, [r5, #4]
 8001332:	2b01      	cmp	r3, #1
    tickstart = HAL_GetTick();
 8001334:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001336:	f241 3788 	movw	r7, #5000	; 0x1388
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800133a:	d115      	bne.n	8001368 <HAL_RCC_ClockConfig+0xc0>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 800133c:	68a3      	ldr	r3, [r4, #8]
 800133e:	f003 030c 	and.w	r3, r3, #12
 8001342:	2b04      	cmp	r3, #4
 8001344:	d0bd      	beq.n	80012c2 <HAL_RCC_ClockConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001346:	f7ff fe13 	bl	8000f70 <HAL_GetTick>
 800134a:	1b80      	subs	r0, r0, r6
 800134c:	42b8      	cmp	r0, r7
 800134e:	d9f5      	bls.n	800133c <HAL_RCC_ClockConfig+0x94>
          return HAL_TIMEOUT;
 8001350:	2003      	movs	r0, #3
 8001352:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8001354:	1e90      	subs	r0, r2, #2
 8001356:	2801      	cmp	r0, #1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001358:	681b      	ldr	r3, [r3, #0]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800135a:	d802      	bhi.n	8001362 <HAL_RCC_ClockConfig+0xba>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800135c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001360:	e7dd      	b.n	800131e <HAL_RCC_ClockConfig+0x76>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001362:	f013 0f02 	tst.w	r3, #2
 8001366:	e7da      	b.n	800131e <HAL_RCC_ClockConfig+0x76>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001368:	2b02      	cmp	r3, #2
 800136a:	d10a      	bne.n	8001382 <HAL_RCC_ClockConfig+0xda>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800136c:	68a3      	ldr	r3, [r4, #8]
 800136e:	f003 030c 	and.w	r3, r3, #12
 8001372:	2b08      	cmp	r3, #8
 8001374:	d0a5      	beq.n	80012c2 <HAL_RCC_ClockConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001376:	f7ff fdfb 	bl	8000f70 <HAL_GetTick>
 800137a:	1b80      	subs	r0, r0, r6
 800137c:	42b8      	cmp	r0, r7
 800137e:	d9f5      	bls.n	800136c <HAL_RCC_ClockConfig+0xc4>
 8001380:	e7e6      	b.n	8001350 <HAL_RCC_ClockConfig+0xa8>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 8001382:	2b03      	cmp	r3, #3
 8001384:	d10f      	bne.n	80013a6 <HAL_RCC_ClockConfig+0xfe>
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 8001386:	68a3      	ldr	r3, [r4, #8]
 8001388:	f003 030c 	and.w	r3, r3, #12
 800138c:	2b0c      	cmp	r3, #12
 800138e:	d098      	beq.n	80012c2 <HAL_RCC_ClockConfig+0x1a>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001390:	f7ff fdee 	bl	8000f70 <HAL_GetTick>
 8001394:	1b80      	subs	r0, r0, r6
 8001396:	42b8      	cmp	r0, r7
 8001398:	d9f5      	bls.n	8001386 <HAL_RCC_ClockConfig+0xde>
 800139a:	e7d9      	b.n	8001350 <HAL_RCC_ClockConfig+0xa8>
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800139c:	f7ff fde8 	bl	8000f70 <HAL_GetTick>
 80013a0:	1b80      	subs	r0, r0, r6
 80013a2:	42b8      	cmp	r0, r7
 80013a4:	d8d4      	bhi.n	8001350 <HAL_RCC_ClockConfig+0xa8>
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80013a6:	68a3      	ldr	r3, [r4, #8]
 80013a8:	f013 0f0c 	tst.w	r3, #12
 80013ac:	d1f6      	bne.n	800139c <HAL_RCC_ClockConfig+0xf4>
 80013ae:	e788      	b.n	80012c2 <HAL_RCC_ClockConfig+0x1a>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80013b0:	b2ca      	uxtb	r2, r1
 80013b2:	701a      	strb	r2, [r3, #0]
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80013b4:	681b      	ldr	r3, [r3, #0]
 80013b6:	f003 030f 	and.w	r3, r3, #15
 80013ba:	4299      	cmp	r1, r3
 80013bc:	d19e      	bne.n	80012fc <HAL_RCC_ClockConfig+0x54>
 80013be:	e786      	b.n	80012ce <HAL_RCC_ClockConfig+0x26>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80013c0:	4a04      	ldr	r2, [pc, #16]	; (80013d4 <HAL_RCC_ClockConfig+0x12c>)
 80013c2:	68e9      	ldr	r1, [r5, #12]
 80013c4:	6893      	ldr	r3, [r2, #8]
 80013c6:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 80013ca:	430b      	orrs	r3, r1
 80013cc:	6093      	str	r3, [r2, #8]
 80013ce:	e781      	b.n	80012d4 <HAL_RCC_ClockConfig+0x2c>
 80013d0:	40023c00 	.word	0x40023c00
 80013d4:	40023800 	.word	0x40023800

080013d8 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80013d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80013dc:	b085      	sub	sp, #20
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80013de:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013e0:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 8001590 <HAL_GPIO_Init+0x1b8>
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 80013e4:	4a68      	ldr	r2, [pc, #416]	; (8001588 <HAL_GPIO_Init+0x1b0>)
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80013e6:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 8001594 <HAL_GPIO_Init+0x1bc>
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80013ea:	9301      	str	r3, [sp, #4]
  for(position = 0U; position < GPIO_NUMBER; position++)
 80013ec:	2300      	movs	r3, #0
    ioposition = 0x01U << position;
 80013ee:	f04f 0e01 	mov.w	lr, #1
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80013f2:	9c01      	ldr	r4, [sp, #4]
    ioposition = 0x01U << position;
 80013f4:	fa0e fe03 	lsl.w	lr, lr, r3
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 80013f8:	ea0e 0604 	and.w	r6, lr, r4
    if(iocurrent == ioposition)
 80013fc:	45b6      	cmp	lr, r6
 80013fe:	f040 80ae 	bne.w	800155e <HAL_GPIO_Init+0x186>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001402:	684c      	ldr	r4, [r1, #4]
 8001404:	f024 0710 	bic.w	r7, r4, #16
 8001408:	2f02      	cmp	r7, #2
 800140a:	d116      	bne.n	800143a <HAL_GPIO_Init+0x62>
        temp = GPIOx->AFR[position >> 3U];
 800140c:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 8001410:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8001414:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 8001418:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800141c:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8001420:	f04f 0c0f 	mov.w	ip, #15
 8001424:	fa0c fc0b 	lsl.w	ip, ip, fp
 8001428:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 800142c:	690d      	ldr	r5, [r1, #16]
 800142e:	fa05 f50b 	lsl.w	r5, r5, fp
 8001432:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3U] = temp;
 8001436:	f8ca 5020 	str.w	r5, [sl, #32]
 800143a:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800143e:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 8001440:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001444:	fa05 f50a 	lsl.w	r5, r5, sl
 8001448:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800144a:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800144e:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001452:	fa0c fc0a 	lsl.w	ip, ip, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001456:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001458:	ea4c 0c0b 	orr.w	ip, ip, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800145c:	2f01      	cmp	r7, #1
      GPIOx->MODER = temp;
 800145e:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001462:	d811      	bhi.n	8001488 <HAL_GPIO_Init+0xb0>
        temp = GPIOx->OSPEEDR;
 8001464:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8001466:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 800146a:	68cf      	ldr	r7, [r1, #12]
 800146c:	fa07 fc0a 	lsl.w	ip, r7, sl
 8001470:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
 8001474:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8001476:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001478:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 800147c:	f3c4 1700 	ubfx	r7, r4, #4, #1
 8001480:	409f      	lsls	r7, r3
 8001482:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8001486:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8001488:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800148a:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800148c:	688f      	ldr	r7, [r1, #8]
 800148e:	fa07 f70a 	lsl.w	r7, r7, sl
 8001492:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 8001494:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001496:	00e5      	lsls	r5, r4, #3
 8001498:	d561      	bpl.n	800155e <HAL_GPIO_Init+0x186>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800149a:	f04f 0b00 	mov.w	fp, #0
 800149e:	f8cd b00c 	str.w	fp, [sp, #12]
 80014a2:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80014a6:	4d39      	ldr	r5, [pc, #228]	; (800158c <HAL_GPIO_Init+0x1b4>)
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80014a8:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
 80014ac:	f8c8 7044 	str.w	r7, [r8, #68]	; 0x44
 80014b0:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
 80014b4:	f407 4780 	and.w	r7, r7, #16384	; 0x4000
 80014b8:	9703      	str	r7, [sp, #12]
 80014ba:	9f03      	ldr	r7, [sp, #12]
 80014bc:	f023 0703 	bic.w	r7, r3, #3
 80014c0:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80014c4:	f507 379c 	add.w	r7, r7, #79872	; 0x13800
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 80014c8:	f003 0c03 	and.w	ip, r3, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 80014cc:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 80014d0:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80014d4:	f04f 0e0f 	mov.w	lr, #15
 80014d8:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80014dc:	42a8      	cmp	r0, r5
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 80014de:	ea2a 0e0e 	bic.w	lr, sl, lr
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 80014e2:	d043      	beq.n	800156c <HAL_GPIO_Init+0x194>
 80014e4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80014e8:	42a8      	cmp	r0, r5
 80014ea:	d041      	beq.n	8001570 <HAL_GPIO_Init+0x198>
 80014ec:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80014f0:	42a8      	cmp	r0, r5
 80014f2:	d03f      	beq.n	8001574 <HAL_GPIO_Init+0x19c>
 80014f4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80014f8:	42a8      	cmp	r0, r5
 80014fa:	d03d      	beq.n	8001578 <HAL_GPIO_Init+0x1a0>
 80014fc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001500:	42a8      	cmp	r0, r5
 8001502:	d03b      	beq.n	800157c <HAL_GPIO_Init+0x1a4>
 8001504:	4548      	cmp	r0, r9
 8001506:	d03b      	beq.n	8001580 <HAL_GPIO_Init+0x1a8>
 8001508:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 800150c:	42a8      	cmp	r0, r5
 800150e:	d039      	beq.n	8001584 <HAL_GPIO_Init+0x1ac>
 8001510:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001514:	42a8      	cmp	r0, r5
 8001516:	bf14      	ite	ne
 8001518:	2508      	movne	r5, #8
 800151a:	2507      	moveq	r5, #7
 800151c:	fa05 f50c 	lsl.w	r5, r5, ip
 8001520:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 8001524:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR;
 8001526:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8001528:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800152a:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 800152e:	bf0c      	ite	eq
 8001530:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8001532:	4335      	orrne	r5, r6
        }
        EXTI->IMR = temp;
 8001534:	6015      	str	r5, [r2, #0]

        temp = EXTI->EMR;
 8001536:	6855      	ldr	r5, [r2, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001538:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 800153c:	bf0c      	ite	eq
 800153e:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 8001540:	4335      	orrne	r5, r6
        }
        EXTI->EMR = temp;
 8001542:	6055      	str	r5, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8001544:	6895      	ldr	r5, [r2, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001546:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 800154a:	bf0c      	ite	eq
 800154c:	403d      	andeq	r5, r7
        {
          temp |= iocurrent;
 800154e:	4335      	orrne	r5, r6
        }
        EXTI->RTSR = temp;
 8001550:	6095      	str	r5, [r2, #8]

        temp = EXTI->FTSR;
 8001552:	68d5      	ldr	r5, [r2, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001554:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 8001556:	bf54      	ite	pl
 8001558:	403d      	andpl	r5, r7
        {
          temp |= iocurrent;
 800155a:	4335      	orrmi	r5, r6
        }
        EXTI->FTSR = temp;
 800155c:	60d5      	str	r5, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800155e:	3301      	adds	r3, #1
 8001560:	2b10      	cmp	r3, #16
 8001562:	f47f af44 	bne.w	80013ee <HAL_GPIO_Init+0x16>
      }
    }
  }
}
 8001566:	b005      	add	sp, #20
 8001568:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 800156c:	465d      	mov	r5, fp
 800156e:	e7d5      	b.n	800151c <HAL_GPIO_Init+0x144>
 8001570:	2501      	movs	r5, #1
 8001572:	e7d3      	b.n	800151c <HAL_GPIO_Init+0x144>
 8001574:	2502      	movs	r5, #2
 8001576:	e7d1      	b.n	800151c <HAL_GPIO_Init+0x144>
 8001578:	2503      	movs	r5, #3
 800157a:	e7cf      	b.n	800151c <HAL_GPIO_Init+0x144>
 800157c:	2504      	movs	r5, #4
 800157e:	e7cd      	b.n	800151c <HAL_GPIO_Init+0x144>
 8001580:	2505      	movs	r5, #5
 8001582:	e7cb      	b.n	800151c <HAL_GPIO_Init+0x144>
 8001584:	2506      	movs	r5, #6
 8001586:	e7c9      	b.n	800151c <HAL_GPIO_Init+0x144>
 8001588:	40013c00 	.word	0x40013c00
 800158c:	40020000 	.word	0x40020000
 8001590:	40023800 	.word	0x40023800
 8001594:	40021400 	.word	0x40021400

08001598 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001598:	b10a      	cbz	r2, 800159e <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 800159a:	6181      	str	r1, [r0, #24]
 800159c:	4770      	bx	lr
 800159e:	0409      	lsls	r1, r1, #16
 80015a0:	e7fb      	b.n	800159a <HAL_GPIO_WritePin+0x2>
 80015a2:	0000      	movs	r0, r0

080015a4 <HAL_UART_Init>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80015a4:	b530      	push	{r4, r5, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 80015a6:	2800      	cmp	r0, #0
 80015a8:	d074      	beq.n	8001694 <HAL_UART_Init+0xf0>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));

  if(huart->gState == HAL_UART_STATE_RESET)
 80015aa:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 80015ae:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80015b2:	b90b      	cbnz	r3, 80015b8 <HAL_UART_Init+0x14>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80015b4:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 80015b8:	6801      	ldr	r1, [r0, #0]
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80015ba:	68c2      	ldr	r2, [r0, #12]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80015bc:	6905      	ldr	r5, [r0, #16]
 80015be:	69c4      	ldr	r4, [r0, #28]
  huart->gState = HAL_UART_STATE_BUSY;
 80015c0:	2324      	movs	r3, #36	; 0x24
 80015c2:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 80015c6:	68cb      	ldr	r3, [r1, #12]
 80015c8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80015cc:	60cb      	str	r3, [r1, #12]
  tmpreg = huart->Instance->CR2;
 80015ce:	690b      	ldr	r3, [r1, #16]
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80015d0:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80015d4:	4313      	orrs	r3, r2
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 80015d6:	610b      	str	r3, [r1, #16]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80015d8:	6883      	ldr	r3, [r0, #8]
  tmpreg = huart->Instance->CR1;
 80015da:	68ca      	ldr	r2, [r1, #12]
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80015dc:	432b      	orrs	r3, r5
 80015de:	6945      	ldr	r5, [r0, #20]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80015e0:	f422 4216 	bic.w	r2, r2, #38400	; 0x9600
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80015e4:	432b      	orrs	r3, r5
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80015e6:	f022 020c 	bic.w	r2, r2, #12
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80015ea:	4323      	orrs	r3, r4
 80015ec:	4313      	orrs	r3, r2
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 80015ee:	60cb      	str	r3, [r1, #12]
  tmpreg = huart->Instance->CR3;
 80015f0:	694b      	ldr	r3, [r1, #20]
  tmpreg |= huart->Init.HwFlowCtl;
 80015f2:	6982      	ldr	r2, [r0, #24]
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 80015f4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  tmpreg |= huart->Init.HwFlowCtl;
 80015f8:	4313      	orrs	r3, r2
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80015fa:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 80015fe:	614b      	str	r3, [r1, #20]
 8001600:	6844      	ldr	r4, [r0, #4]
 8001602:	4b25      	ldr	r3, [pc, #148]	; (8001698 <HAL_UART_Init+0xf4>)
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8001604:	d136      	bne.n	8001674 <HAL_UART_Init+0xd0>
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8001606:	4299      	cmp	r1, r3
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8001608:	ea4f 0444 	mov.w	r4, r4, lsl #1
 800160c:	4a23      	ldr	r2, [pc, #140]	; (800169c <HAL_UART_Init+0xf8>)
 800160e:	fbb2 f2f4 	udiv	r2, r2, r4
 8001612:	f04f 0464 	mov.w	r4, #100	; 0x64
 8001616:	fbb2 f5f4 	udiv	r5, r2, r4
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 800161a:	d003      	beq.n	8001624 <HAL_UART_Init+0x80>
 800161c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001620:	4299      	cmp	r1, r3
 8001622:	d123      	bne.n	800166c <HAL_UART_Init+0xc8>
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8001624:	fb04 2215 	mls	r2, r4, r5, r2
 8001628:	00d3      	lsls	r3, r2, #3
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 800162a:	3332      	adds	r3, #50	; 0x32
 800162c:	fbb3 f3f4 	udiv	r3, r3, r4
 8001630:	f003 0207 	and.w	r2, r3, #7
 8001634:	005b      	lsls	r3, r3, #1
 8001636:	eb02 1205 	add.w	r2, r2, r5, lsl #4
 800163a:	f403 73f8 	and.w	r3, r3, #496	; 0x1f0
 800163e:	4413      	add	r3, r2
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8001640:	608b      	str	r3, [r1, #8]
  UART_SetConfig(huart);

  /* In asynchronous mode, the following bits must be kept cleared:
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8001642:	690b      	ldr	r3, [r1, #16]
 8001644:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 8001648:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800164a:	694b      	ldr	r3, [r1, #20]
 800164c:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 8001650:	614b      	str	r3, [r1, #20]

  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8001652:	68cb      	ldr	r3, [r1, #12]
 8001654:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001658:	60cb      	str	r3, [r1, #12]

  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->gState= HAL_UART_STATE_READY;
 800165a:	2220      	movs	r2, #32
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800165c:	2300      	movs	r3, #0
 800165e:	63c3      	str	r3, [r0, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8001660:	f880 2039 	strb.w	r2, [r0, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8001664:	f880 203a 	strb.w	r2, [r0, #58]	; 0x3a

  return HAL_OK;
 8001668:	4618      	mov	r0, r3
 800166a:	bd30      	pop	{r4, r5, pc}
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 800166c:	fb04 2315 	mls	r3, r4, r5, r2
 8001670:	00db      	lsls	r3, r3, #3
 8001672:	e7da      	b.n	800162a <HAL_UART_Init+0x86>
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8001674:	00a2      	lsls	r2, r4, #2
 8001676:	2464      	movs	r4, #100	; 0x64
 8001678:	4b08      	ldr	r3, [pc, #32]	; (800169c <HAL_UART_Init+0xf8>)
 800167a:	fbb3 f2f2 	udiv	r2, r3, r2
 800167e:	fbb2 f5f4 	udiv	r5, r2, r4
 8001682:	fb04 2315 	mls	r3, r4, r5, r2
 8001686:	011b      	lsls	r3, r3, #4
 8001688:	3332      	adds	r3, #50	; 0x32
 800168a:	fbb3 f3f4 	udiv	r3, r3, r4
 800168e:	eb03 1305 	add.w	r3, r3, r5, lsl #4
 8001692:	e7d5      	b.n	8001640 <HAL_UART_Init+0x9c>
    return HAL_ERROR;
 8001694:	2001      	movs	r0, #1
}
 8001696:	bd30      	pop	{r4, r5, pc}
 8001698:	40011000 	.word	0x40011000
 800169c:	0afc8000 	.word	0x0afc8000

080016a0 <HAL_UART_Transmit>:
{
  uint16_t* tmp;
  //uint32_t tickstart = 0U;

  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
 80016a0:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 80016a4:	2b20      	cmp	r3, #32
 80016a6:	d13c      	bne.n	8001722 <HAL_UART_Transmit+0x82>
  {
    if((pData == NULL ) || (Size == 0))
 80016a8:	2900      	cmp	r1, #0
 80016aa:	d038      	beq.n	800171e <HAL_UART_Transmit+0x7e>
 80016ac:	2a00      	cmp	r2, #0
 80016ae:	d036      	beq.n	800171e <HAL_UART_Transmit+0x7e>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 80016b0:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 80016b4:	2b01      	cmp	r3, #1
 80016b6:	d034      	beq.n	8001722 <HAL_UART_Transmit+0x82>
 80016b8:	2301      	movs	r3, #1
 80016ba:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80016be:	2300      	movs	r3, #0
 80016c0:	63c3      	str	r3, [r0, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80016c2:	2321      	movs	r3, #33	; 0x21
 80016c4:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39

    /* Init tickstart for timeout managment */
    //tickstart = HAL_GetTick();

    huart->TxXferSize = Size;
 80016c8:	8482      	strh	r2, [r0, #36]	; 0x24
    huart->TxXferCount = Size;
 80016ca:	84c2      	strh	r2, [r0, #38]	; 0x26
    while(huart->TxXferCount > 0U)
 80016cc:	8cc2      	ldrh	r2, [r0, #38]	; 0x26
 80016ce:	6803      	ldr	r3, [r0, #0]
 80016d0:	b292      	uxth	r2, r2
 80016d2:	b952      	cbnz	r2, 80016ea <HAL_UART_Transmit+0x4a>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 80016d4:	681a      	ldr	r2, [r3, #0]
 80016d6:	0652      	lsls	r2, r2, #25
 80016d8:	d5fc      	bpl.n	80016d4 <HAL_UART_Transmit+0x34>
    {
      return HAL_TIMEOUT;
    }

    /* At end of Tx process, restore huart->gState to Ready */
      huart->gState = HAL_UART_STATE_READY;
 80016da:	2320      	movs	r3, #32
 80016dc:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 80016e0:	2300      	movs	r3, #0
 80016e2:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

    return HAL_OK;
 80016e6:	4618      	mov	r0, r3
 80016e8:	4770      	bx	lr
      huart->TxXferCount--;
 80016ea:	8cc2      	ldrh	r2, [r0, #38]	; 0x26
 80016ec:	3a01      	subs	r2, #1
 80016ee:	b292      	uxth	r2, r2
 80016f0:	84c2      	strh	r2, [r0, #38]	; 0x26
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 80016f2:	6882      	ldr	r2, [r0, #8]
 80016f4:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 80016f8:	d10a      	bne.n	8001710 <HAL_UART_Transmit+0x70>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 80016fa:	681a      	ldr	r2, [r3, #0]
 80016fc:	0612      	lsls	r2, r2, #24
 80016fe:	d5fc      	bpl.n	80016fa <HAL_UART_Transmit+0x5a>
        huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
 8001700:	880a      	ldrh	r2, [r1, #0]
 8001702:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8001706:	605a      	str	r2, [r3, #4]
        if(huart->Init.Parity == UART_PARITY_NONE)
 8001708:	6903      	ldr	r3, [r0, #16]
 800170a:	b933      	cbnz	r3, 800171a <HAL_UART_Transmit+0x7a>
          pData +=2U;
 800170c:	3102      	adds	r1, #2
 800170e:	e7dd      	b.n	80016cc <HAL_UART_Transmit+0x2c>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 8001710:	681a      	ldr	r2, [r3, #0]
 8001712:	0612      	lsls	r2, r2, #24
 8001714:	d5fc      	bpl.n	8001710 <HAL_UART_Transmit+0x70>
        huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
 8001716:	780a      	ldrb	r2, [r1, #0]
 8001718:	605a      	str	r2, [r3, #4]
 800171a:	3101      	adds	r1, #1
 800171c:	e7d6      	b.n	80016cc <HAL_UART_Transmit+0x2c>
      return  HAL_ERROR;
 800171e:	2001      	movs	r0, #1
 8001720:	4770      	bx	lr
  }
  else
  {
    return HAL_BUSY;
 8001722:	2002      	movs	r0, #2
  }
}
 8001724:	4770      	bx	lr

08001726 <HAL_UART_Receive>:
{
  uint16_t* tmp;
  //uint32_t tickstart = 0U;

  /* Check that a Rx process is not already ongoing */
  if(huart->RxState == HAL_UART_STATE_READY)
 8001726:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 800172a:	2b20      	cmp	r3, #32
{
 800172c:	b510      	push	{r4, lr}
  if(huart->RxState == HAL_UART_STATE_READY)
 800172e:	d142      	bne.n	80017b6 <HAL_UART_Receive+0x90>
  {
    if((pData == NULL ) || (Size == 0))
 8001730:	2900      	cmp	r1, #0
 8001732:	d03e      	beq.n	80017b2 <HAL_UART_Receive+0x8c>
 8001734:	2a00      	cmp	r2, #0
 8001736:	d03c      	beq.n	80017b2 <HAL_UART_Receive+0x8c>
    {
      return  HAL_ERROR;
    }

    /* Process Locked */
    __HAL_LOCK(huart);
 8001738:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 800173c:	2b01      	cmp	r3, #1
 800173e:	d03a      	beq.n	80017b6 <HAL_UART_Receive+0x90>
 8001740:	2301      	movs	r3, #1
 8001742:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8001746:	2300      	movs	r3, #0
 8001748:	63c3      	str	r3, [r0, #60]	; 0x3c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800174a:	2322      	movs	r3, #34	; 0x22
 800174c:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a

    /* Init tickstart for timeout managment */
    //tickstart = HAL_GetTick();

    huart->RxXferSize = Size;
 8001750:	8582      	strh	r2, [r0, #44]	; 0x2c
    huart->RxXferCount = Size;
 8001752:	85c2      	strh	r2, [r0, #46]	; 0x2e

    /* Check the remain data to be received */
    while(huart->RxXferCount > 0U)
 8001754:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 8001756:	b29b      	uxth	r3, r3
 8001758:	b933      	cbnz	r3, 8001768 <HAL_UART_Receive+0x42>

      }
    }

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 800175a:	2220      	movs	r2, #32
 800175c:	f880 203a 	strb.w	r2, [r0, #58]	; 0x3a

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8001760:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

    return HAL_OK;
 8001764:	4618      	mov	r0, r3
 8001766:	bd10      	pop	{r4, pc}
      huart->RxXferCount--;
 8001768:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 800176a:	3b01      	subs	r3, #1
 800176c:	b29b      	uxth	r3, r3
 800176e:	85c3      	strh	r3, [r0, #46]	; 0x2e
      if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8001770:	6883      	ldr	r3, [r0, #8]
 8001772:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8001776:	6803      	ldr	r3, [r0, #0]
 8001778:	d10e      	bne.n	8001798 <HAL_UART_Receive+0x72>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 800177a:	681a      	ldr	r2, [r3, #0]
 800177c:	0694      	lsls	r4, r2, #26
 800177e:	d5fc      	bpl.n	800177a <HAL_UART_Receive+0x54>
        if(huart->Init.Parity == UART_PARITY_NONE)
 8001780:	6902      	ldr	r2, [r0, #16]
          *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001782:	685b      	ldr	r3, [r3, #4]
        if(huart->Init.Parity == UART_PARITY_NONE)
 8001784:	b922      	cbnz	r2, 8001790 <HAL_UART_Receive+0x6a>
          *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8001786:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800178a:	f821 3b02 	strh.w	r3, [r1], #2
 800178e:	e7e1      	b.n	8001754 <HAL_UART_Receive+0x2e>
          *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
 8001790:	b2db      	uxtb	r3, r3
 8001792:	f821 3b01 	strh.w	r3, [r1], #1
 8001796:	e7dd      	b.n	8001754 <HAL_UART_Receive+0x2e>
  while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status);
 8001798:	681a      	ldr	r2, [r3, #0]
 800179a:	0692      	lsls	r2, r2, #26
 800179c:	d5fc      	bpl.n	8001798 <HAL_UART_Receive+0x72>
        if(huart->Init.Parity == UART_PARITY_NONE)
 800179e:	6904      	ldr	r4, [r0, #16]
          *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 80017a0:	685b      	ldr	r3, [r3, #4]
 80017a2:	1c4a      	adds	r2, r1, #1
        if(huart->Init.Parity == UART_PARITY_NONE)
 80017a4:	b914      	cbnz	r4, 80017ac <HAL_UART_Receive+0x86>
          *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 80017a6:	700b      	strb	r3, [r1, #0]
 80017a8:	4611      	mov	r1, r2
 80017aa:	e7d3      	b.n	8001754 <HAL_UART_Receive+0x2e>
 80017ac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80017b0:	e7f9      	b.n	80017a6 <HAL_UART_Receive+0x80>
      return  HAL_ERROR;
 80017b2:	2001      	movs	r0, #1
 80017b4:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 80017b6:	2002      	movs	r0, #2
  }
}
 80017b8:	bd10      	pop	{r4, pc}
 80017ba:	0000      	movs	r0, r0

080017bc <Reset_Handler>:
 80017bc:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80017be:	e003      	b.n	80017c8 <LoopCopyDataInit>

080017c0 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80017c0:	4b0b      	ldr	r3, [pc, #44]	; (80017f0 <LoopForever+0x2>)
	ldr	r3, [r3, r1]
 80017c2:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80017c4:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80017c6:	3104      	adds	r1, #4

080017c8 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80017c8:	480a      	ldr	r0, [pc, #40]	; (80017f4 <LoopForever+0x6>)
	ldr	r3, =_edata
 80017ca:	4b0b      	ldr	r3, [pc, #44]	; (80017f8 <LoopForever+0xa>)
	adds	r2, r0, r1
 80017cc:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80017ce:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80017d0:	d3f6      	bcc.n	80017c0 <CopyDataInit>
	ldr	r2, =_sbss
 80017d2:	4a0a      	ldr	r2, [pc, #40]	; (80017fc <LoopForever+0xe>)
	b	LoopFillZerobss
 80017d4:	e002      	b.n	80017dc <LoopFillZerobss>

080017d6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs r3, #0
 80017d6:	2300      	movs	r3, #0
 	str  r3, [r2]
 80017d8:	6013      	str	r3, [r2, #0]
	adds r2, r2, #4
 80017da:	3204      	adds	r2, #4

080017dc <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80017dc:	4b08      	ldr	r3, [pc, #32]	; (8001800 <LoopForever+0x12>)
	cmp	r2, r3
 80017de:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80017e0:	d3f9      	bcc.n	80017d6 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80017e2:	f3af 8000 	nop.w
/* Call static constructors */
    bl __libc_init_array
 80017e6:	f7ff f95b 	bl	8000aa0 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80017ea:	f7ff fa31 	bl	8000c50 <main>

080017ee <LoopForever>:

LoopForever:
    b LoopForever
 80017ee:	e7fe      	b.n	80017ee <LoopForever>
 80017f0:	08001858 	.word	0x08001858
 80017f4:	20000000 	.word	0x20000000
 80017f8:	20000430 	.word	0x20000430
 80017fc:	20000430 	.word	0x20000430
 8001800:	20000564 	.word	0x20000564

08001804 <BusFault_Handler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8001804:	e7fe      	b.n	8001804 <BusFault_Handler>
 8001806:	0000      	movs	r0, r0

08001808 <register_fini>:
 8001808:	4b02      	ldr	r3, [pc, #8]	; (8001814 <register_fini+0xc>)
 800180a:	b113      	cbz	r3, 8001812 <register_fini+0xa>
 800180c:	4802      	ldr	r0, [pc, #8]	; (8001818 <register_fini+0x10>)
 800180e:	f7ff b927 	b.w	8000a60 <atexit>
 8001812:	4770      	bx	lr
 8001814:	00000000 	.word	0x00000000
 8001818:	08000a6d 	.word	0x08000a6d

0800181c <_init>:
 800181c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800181e:	bf00      	nop
 8001820:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001822:	bc08      	pop	{r3}
 8001824:	469e      	mov	lr, r3
 8001826:	4770      	bx	lr

08001828 <_fini>:
 8001828:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800182a:	bf00      	nop
 800182c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800182e:	bc08      	pop	{r3}
 8001830:	469e      	mov	lr, r3
 8001832:	4770      	bx	lr
